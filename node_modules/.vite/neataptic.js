import {
  __commonJS,
  __esm,
  __export
} from "./chunk-ELXAK55F.js";

// node_modules/neataptic/src/methods/activation.js
var require_activation = __commonJS({
  "node_modules/neataptic/src/methods/activation.js"(exports, module) {
    var activation = {
      LOGISTIC: function(x, derivate) {
        var fx = 1 / (1 + Math.exp(-x));
        if (!derivate)
          return fx;
        return fx * (1 - fx);
      },
      TANH: function(x, derivate) {
        if (derivate)
          return 1 - Math.pow(Math.tanh(x), 2);
        return Math.tanh(x);
      },
      IDENTITY: function(x, derivate) {
        return derivate ? 1 : x;
      },
      STEP: function(x, derivate) {
        return derivate ? 0 : x > 0 ? 1 : 0;
      },
      RELU: function(x, derivate) {
        if (derivate)
          return x > 0 ? 1 : 0;
        return x > 0 ? x : 0;
      },
      SOFTSIGN: function(x, derivate) {
        var d = 1 + Math.abs(x);
        if (derivate)
          return x / Math.pow(d, 2);
        return x / d;
      },
      SINUSOID: function(x, derivate) {
        if (derivate)
          return Math.cos(x);
        return Math.sin(x);
      },
      GAUSSIAN: function(x, derivate) {
        var d = Math.exp(-Math.pow(x, 2));
        if (derivate)
          return -2 * x * d;
        return d;
      },
      BENT_IDENTITY: function(x, derivate) {
        var d = Math.sqrt(Math.pow(x, 2) + 1);
        if (derivate)
          return x / (2 * d) + 1;
        return (d - 1) / 2 + x;
      },
      BIPOLAR: function(x, derivate) {
        return derivate ? 0 : x > 0 ? 1 : -1;
      },
      BIPOLAR_SIGMOID: function(x, derivate) {
        var d = 2 / (1 + Math.exp(-x)) - 1;
        if (derivate)
          return 1 / 2 * (1 + d) * (1 - d);
        return d;
      },
      HARD_TANH: function(x, derivate) {
        if (derivate)
          return x > -1 && x < 1 ? 1 : 0;
        return Math.max(-1, Math.min(1, x));
      },
      ABSOLUTE: function(x, derivate) {
        if (derivate)
          return x < 0 ? -1 : 1;
        return Math.abs(x);
      },
      INVERSE: function(x, derivate) {
        if (derivate)
          return -1;
        return 1 - x;
      },
      SELU: function(x, derivate) {
        var alpha = 1.6732632423543772;
        var scale = 1.0507009873554805;
        var fx = x > 0 ? x : alpha * Math.exp(x) - alpha;
        if (derivate) {
          return x > 0 ? scale : (fx + alpha) * scale;
        }
        return fx * scale;
      }
    };
    module.exports = activation;
  }
});

// node_modules/neataptic/src/methods/mutation.js
var require_mutation = __commonJS({
  "node_modules/neataptic/src/methods/mutation.js"(exports, module) {
    var activation = require_activation();
    var mutation = {
      ADD_NODE: {
        name: "ADD_NODE"
      },
      SUB_NODE: {
        name: "SUB_NODE",
        keep_gates: true
      },
      ADD_CONN: {
        name: "ADD_CONN"
      },
      SUB_CONN: {
        name: "REMOVE_CONN"
      },
      MOD_WEIGHT: {
        name: "MOD_WEIGHT",
        min: -1,
        max: 1
      },
      MOD_BIAS: {
        name: "MOD_BIAS",
        min: -1,
        max: 1
      },
      MOD_ACTIVATION: {
        name: "MOD_ACTIVATION",
        mutateOutput: true,
        allowed: [
          activation.LOGISTIC,
          activation.TANH,
          activation.RELU,
          activation.IDENTITY,
          activation.STEP,
          activation.SOFTSIGN,
          activation.SINUSOID,
          activation.GAUSSIAN,
          activation.BENT_IDENTITY,
          activation.BIPOLAR,
          activation.BIPOLAR_SIGMOID,
          activation.HARD_TANH,
          activation.ABSOLUTE,
          activation.INVERSE,
          activation.SELU
        ]
      },
      ADD_SELF_CONN: {
        name: "ADD_SELF_CONN"
      },
      SUB_SELF_CONN: {
        name: "SUB_SELF_CONN"
      },
      ADD_GATE: {
        name: "ADD_GATE"
      },
      SUB_GATE: {
        name: "SUB_GATE"
      },
      ADD_BACK_CONN: {
        name: "ADD_BACK_CONN"
      },
      SUB_BACK_CONN: {
        name: "SUB_BACK_CONN"
      },
      SWAP_NODES: {
        name: "SWAP_NODES",
        mutateOutput: true
      }
    };
    mutation.ALL = [
      mutation.ADD_NODE,
      mutation.SUB_NODE,
      mutation.ADD_CONN,
      mutation.SUB_CONN,
      mutation.MOD_WEIGHT,
      mutation.MOD_BIAS,
      mutation.MOD_ACTIVATION,
      mutation.ADD_GATE,
      mutation.SUB_GATE,
      mutation.ADD_SELF_CONN,
      mutation.SUB_SELF_CONN,
      mutation.ADD_BACK_CONN,
      mutation.SUB_BACK_CONN,
      mutation.SWAP_NODES
    ];
    mutation.FFW = [
      mutation.ADD_NODE,
      mutation.SUB_NODE,
      mutation.ADD_CONN,
      mutation.SUB_CONN,
      mutation.MOD_WEIGHT,
      mutation.MOD_BIAS,
      mutation.MOD_ACTIVATION,
      mutation.SWAP_NODES
    ];
    module.exports = mutation;
  }
});

// node_modules/neataptic/src/methods/selection.js
var require_selection = __commonJS({
  "node_modules/neataptic/src/methods/selection.js"(exports, module) {
    var selection = {
      FITNESS_PROPORTIONATE: {
        name: "FITNESS_PROPORTIONATE"
      },
      POWER: {
        name: "POWER",
        power: 4
      },
      TOURNAMENT: {
        name: "TOURNAMENT",
        size: 5,
        probability: 0.5
      }
    };
    module.exports = selection;
  }
});

// node_modules/neataptic/src/methods/crossover.js
var require_crossover = __commonJS({
  "node_modules/neataptic/src/methods/crossover.js"(exports, module) {
    var crossover = {
      SINGLE_POINT: {
        name: "SINGLE_POINT",
        config: [0.4]
      },
      TWO_POINT: {
        name: "TWO_POINT",
        config: [0.4, 0.9]
      },
      UNIFORM: {
        name: "UNIFORM"
      },
      AVERAGE: {
        name: "AVERAGE"
      }
    };
    module.exports = crossover;
  }
});

// node_modules/neataptic/src/methods/cost.js
var require_cost = __commonJS({
  "node_modules/neataptic/src/methods/cost.js"(exports, module) {
    var cost = {
      CROSS_ENTROPY: function(target, output) {
        var error = 0;
        for (var i = 0; i < output.length; i++) {
          error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));
        }
        return error / output.length;
      },
      MSE: function(target, output) {
        var error = 0;
        for (var i = 0; i < output.length; i++) {
          error += Math.pow(target[i] - output[i], 2);
        }
        return error / output.length;
      },
      BINARY: function(target, output) {
        var misses = 0;
        for (var i = 0; i < output.length; i++) {
          misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);
        }
        return misses;
      },
      MAE: function(target, output) {
        var error = 0;
        for (var i = 0; i < output.length; i++) {
          error += Math.abs(target[i] - output[i]);
        }
        return error / output.length;
      },
      MAPE: function(target, output) {
        var error = 0;
        for (var i = 0; i < output.length; i++) {
          error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));
        }
        return error / output.length;
      },
      MSLE: function(target, output) {
        var error = 0;
        for (var i = 0; i < output.length; i++) {
          error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));
        }
        return error;
      },
      HINGE: function(target, output) {
        var error = 0;
        for (var i = 0; i < output.length; i++) {
          error += Math.max(0, 1 - target[i] * output[i]);
        }
        return error;
      }
    };
    module.exports = cost;
  }
});

// node_modules/neataptic/src/methods/gating.js
var require_gating = __commonJS({
  "node_modules/neataptic/src/methods/gating.js"(exports, module) {
    var gating = {
      OUTPUT: {
        name: "OUTPUT"
      },
      INPUT: {
        name: "INPUT"
      },
      SELF: {
        name: "SELF"
      }
    };
    module.exports = gating;
  }
});

// node_modules/neataptic/src/methods/connection.js
var require_connection = __commonJS({
  "node_modules/neataptic/src/methods/connection.js"(exports, module) {
    var connection = {
      ALL_TO_ALL: {
        name: "OUTPUT"
      },
      ALL_TO_ELSE: {
        name: "INPUT"
      },
      ONE_TO_ONE: {
        name: "SELF"
      }
    };
    module.exports = connection;
  }
});

// node_modules/neataptic/src/methods/rate.js
var require_rate = __commonJS({
  "node_modules/neataptic/src/methods/rate.js"(exports, module) {
    var rate = {
      FIXED: function() {
        var func = function(baseRate, iteration) {
          return baseRate;
        };
        return func;
      },
      STEP: function(gamma, stepSize) {
        gamma = gamma || 0.9;
        stepSize = stepSize || 100;
        var func = function(baseRate, iteration) {
          return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));
        };
        return func;
      },
      EXP: function(gamma) {
        gamma = gamma || 0.999;
        var func = function(baseRate, iteration) {
          return baseRate * Math.pow(gamma, iteration);
        };
        return func;
      },
      INV: function(gamma, power) {
        gamma = gamma || 1e-3;
        power = power || 2;
        var func = function(baseRate, iteration) {
          return baseRate * Math.pow(1 + gamma * iteration, -power);
        };
        return func;
      }
    };
    module.exports = rate;
  }
});

// node_modules/neataptic/src/methods/methods.js
var require_methods = __commonJS({
  "node_modules/neataptic/src/methods/methods.js"(exports, module) {
    var methods = {
      activation: require_activation(),
      mutation: require_mutation(),
      selection: require_selection(),
      crossover: require_crossover(),
      cost: require_cost(),
      gating: require_gating(),
      connection: require_connection(),
      rate: require_rate()
    };
    module.exports = methods;
  }
});

// node_modules/neataptic/src/architecture/connection.js
var require_connection2 = __commonJS({
  "node_modules/neataptic/src/architecture/connection.js"(exports, module) {
    module.exports = Connection;
    function Connection(from, to, weight) {
      this.from = from;
      this.to = to;
      this.gain = 1;
      this.weight = typeof weight === "undefined" ? Math.random() * 0.2 - 0.1 : weight;
      this.gater = null;
      this.elegibility = 0;
      this.previousDeltaWeight = 0;
      this.totalDeltaWeight = 0;
      this.xtrace = {
        nodes: [],
        values: []
      };
    }
    Connection.prototype = {
      toJSON: function() {
        var json = {
          weight: this.weight
        };
        return json;
      }
    };
    Connection.innovationID = function(a, b) {
      return 1 / 2 * (a + b) * (a + b + 1) + b;
    };
  }
});

// browser-external:child_process
var child_process_exports = {};
__export(child_process_exports, {
  default: () => child_process_default
});
var child_process_default;
var init_child_process = __esm({
  "browser-external:child_process"() {
    child_process_default = new Proxy({}, {
      get() {
        throw new Error('Module "child_process" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:path
var path_exports = {};
__export(path_exports, {
  default: () => path_default
});
var path_default;
var init_path = __esm({
  "browser-external:path"() {
    path_default = new Proxy({}, {
      get() {
        throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/neataptic/src/multithreading/workers/node/testworker.js
var require_testworker = __commonJS({
  "node_modules/neataptic/src/multithreading/workers/node/testworker.js"(exports, module) {
    module.exports = TestWorker;
    var cp = (init_child_process(), child_process_exports);
    var path = (init_path(), path_exports);
    function TestWorker(dataSet, cost) {
      this.worker = cp.fork(path.join(__dirname, "/worker"));
      this.worker.send({ set: dataSet, cost: cost.name });
    }
    TestWorker.prototype = {
      evaluate: function(network) {
        return new Promise((resolve, reject) => {
          var serialized = network.serialize();
          var data = {
            activations: serialized[0],
            states: serialized[1],
            conns: serialized[2]
          };
          var _that = this.worker;
          this.worker.on("message", function callback(e) {
            _that.removeListener("message", callback);
            resolve(e);
          });
          this.worker.send(data);
        });
      },
      terminate: function() {
        this.worker.kill();
      }
    };
  }
});

// node_modules/neataptic/src/multithreading/workers/browser/testworker.js
var require_testworker2 = __commonJS({
  "node_modules/neataptic/src/multithreading/workers/browser/testworker.js"(exports, module) {
    module.exports = TestWorker;
    var multi = require_multi();
    function TestWorker(dataSet, cost) {
      var blob = new Blob([this._createBlobString(cost)]);
      this.url = window.URL.createObjectURL(blob);
      this.worker = new Worker(this.url);
      var data = { set: new Float64Array(dataSet).buffer };
      this.worker.postMessage(data, [data.set]);
    }
    TestWorker.prototype = {
      evaluate: function(network) {
        return new Promise((resolve, reject) => {
          var serialized = network.serialize();
          var data = {
            activations: new Float64Array(serialized[0]).buffer,
            states: new Float64Array(serialized[1]).buffer,
            conns: new Float64Array(serialized[2]).buffer
          };
          this.worker.onmessage = function(e) {
            var error = new Float64Array(e.data.buffer)[0];
            resolve(error);
          };
          this.worker.postMessage(data, [data.activations, data.states, data.conns]);
        });
      },
      terminate: function() {
        this.worker.terminate();
        window.URL.revokeObjectURL(this.url);
      },
      _createBlobString: function(cost) {
        var source = `
      var F = [${multi.activations.toString()}];
      var cost = ${cost.toString()};
      var multi = {
        deserializeDataSet: ${multi.deserializeDataSet.toString()},
        testSerializedSet: ${multi.testSerializedSet.toString()},
        activateSerializedNetwork: ${multi.activateSerializedNetwork.toString()}
      };

      this.onmessage = function (e) {
        if(typeof e.data.set === 'undefined'){
          var A = new Float64Array(e.data.activations);
          var S = new Float64Array(e.data.states);
          var data = new Float64Array(e.data.conns);

          var error = multi.testSerializedSet(set, cost, A, S, data, F);

          var answer = { buffer: new Float64Array([error ]).buffer };
          postMessage(answer, [answer.buffer]);
        } else {
          set = multi.deserializeDataSet(new Float64Array(e.data.set));
        }
      };`;
        return source;
      }
    };
  }
});

// node_modules/neataptic/src/multithreading/workers/workers.js
var require_workers = __commonJS({
  "node_modules/neataptic/src/multithreading/workers/workers.js"(exports, module) {
    var workers = {
      node: {
        TestWorker: require_testworker()
      },
      browser: {
        TestWorker: require_testworker2()
      }
    };
    module.exports = workers;
  }
});

// node_modules/neataptic/src/multithreading/multi.js
var require_multi = __commonJS({
  "node_modules/neataptic/src/multithreading/multi.js"(exports, module) {
    var multi = {
      workers: require_workers(),
      serializeDataSet: function(dataSet) {
        var serialized = [dataSet[0].input.length, dataSet[0].output.length];
        for (var i2 = 0; i2 < dataSet.length; i2++) {
          var j;
          for (j = 0; j < serialized[0]; j++) {
            serialized.push(dataSet[i2].input[j]);
          }
          for (j = 0; j < serialized[1]; j++) {
            serialized.push(dataSet[i2].output[j]);
          }
        }
        return serialized;
      },
      activateSerializedNetwork: function(input, A, S, data, F) {
        for (var i2 = 0; i2 < data[0]; i2++)
          A[i2] = input[i2];
        for (i2 = 2; i2 < data.length; i2++) {
          let index = data[i2++];
          let bias = data[i2++];
          let squash = data[i2++];
          let selfweight = data[i2++];
          let selfgater = data[i2++];
          S[index] = (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;
          while (data[i2] !== -2) {
            S[index] += A[data[i2++]] * data[i2++] * (data[i2++] === -1 ? 1 : A[data[i2 - 1]]);
          }
          A[index] = F[squash](S[index]);
        }
        var output = [];
        for (i2 = A.length - data[1]; i2 < A.length; i2++)
          output.push(A[i2]);
        return output;
      },
      deserializeDataSet: function(serializedSet) {
        var set = [];
        var sampleSize = serializedSet[0] + serializedSet[1];
        for (var i2 = 0; i2 < (serializedSet.length - 2) / sampleSize; i2++) {
          let input = [];
          for (var j = 2 + i2 * sampleSize; j < 2 + i2 * sampleSize + serializedSet[0]; j++) {
            input.push(serializedSet[j]);
          }
          let output = [];
          for (j = 2 + i2 * sampleSize + serializedSet[0]; j < 2 + i2 * sampleSize + sampleSize; j++) {
            output.push(serializedSet[j]);
          }
          set.push(input);
          set.push(output);
        }
        return set;
      },
      activations: [
        function(x) {
          return 1 / (1 + Math.exp(-x));
        },
        function(x) {
          return Math.tanh(x);
        },
        function(x) {
          return x;
        },
        function(x) {
          return x > 0 ? 1 : 0;
        },
        function(x) {
          return x > 0 ? x : 0;
        },
        function(x) {
          return x / (1 + Math.abs(x));
        },
        function(x) {
          return Math.sin(x);
        },
        function(x) {
          return Math.exp(-Math.pow(x, 2));
        },
        function(x) {
          return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x;
        },
        function(x) {
          return x > 0 ? 1 : -1;
        },
        function(x) {
          return 2 / (1 + Math.exp(-x)) - 1;
        },
        function(x) {
          return Math.max(-1, Math.min(1, x));
        },
        function(x) {
          return Math.abs(x);
        },
        function(x) {
          return 1 - x;
        },
        function(x) {
          var a = 1.6732632423543772;
          return (x > 0 ? x : a * Math.exp(x) - a) * 1.0507009873554805;
        }
      ]
    };
    multi.testSerializedSet = function(set, cost, A, S, data, F) {
      var error = 0;
      for (var i2 = 0; i2 < set.length; i2 += 2) {
        let output = multi.activateSerializedNetwork(set[i2], A, S, data, F);
        error += cost(set[i2 + 1], output);
      }
      return error / (set.length / 2);
    };
    for (i in multi) {
      module.exports[i] = multi[i];
    }
    var i;
  }
});

// node_modules/neataptic/src/config.js
var require_config = __commonJS({
  "node_modules/neataptic/src/config.js"(exports, module) {
    var config = {
      warnings: false
    };
    module.exports = config;
  }
});

// node_modules/neataptic/src/neat.js
var require_neat = __commonJS({
  "node_modules/neataptic/src/neat.js"(exports, module) {
    module.exports = Neat;
    var Network = require_network();
    var methods = require_methods();
    var config = require_config();
    var selection = methods.selection;
    function Neat(input, output, fitness, options) {
      this.input = input;
      this.output = output;
      this.fitness = fitness;
      options = options || {};
      this.equal = options.equal || false;
      this.clear = options.clear || false;
      this.popsize = options.popsize || 50;
      this.elitism = options.elitism || 0;
      this.provenance = options.provenance || 0;
      this.mutationRate = options.mutationRate || 0.3;
      this.mutationAmount = options.mutationAmount || 1;
      this.fitnessPopulation = options.fitnessPopulation || false;
      this.selection = options.selection || methods.selection.POWER;
      this.crossover = options.crossover || [
        methods.crossover.SINGLE_POINT,
        methods.crossover.TWO_POINT,
        methods.crossover.UNIFORM,
        methods.crossover.AVERAGE
      ];
      this.mutation = options.mutation || methods.mutation.FFW;
      this.template = options.network || false;
      this.maxNodes = options.maxNodes || Infinity;
      this.maxConns = options.maxConns || Infinity;
      this.maxGates = options.maxGates || Infinity;
      this.selectMutationMethod = typeof options.mutationSelection === "function" ? options.mutationSelection.bind(this) : this.selectMutationMethod;
      this.generation = 0;
      this.createPool(this.template);
    }
    Neat.prototype = {
      createPool: function(network) {
        this.population = [];
        for (var i = 0; i < this.popsize; i++) {
          var copy;
          if (this.template) {
            copy = Network.fromJSON(network.toJSON());
          } else {
            copy = new Network(this.input, this.output);
          }
          copy.score = void 0;
          this.population.push(copy);
        }
      },
      evolve: async function() {
        if (typeof this.population[this.population.length - 1].score === "undefined") {
          await this.evaluate();
        }
        this.sort();
        var fittest = Network.fromJSON(this.population[0].toJSON());
        fittest.score = this.population[0].score;
        var newPopulation = [];
        var elitists = [];
        for (var i = 0; i < this.elitism; i++) {
          elitists.push(this.population[i]);
        }
        for (i = 0; i < this.provenance; i++) {
          newPopulation.push(Network.fromJSON(this.template.toJSON()));
        }
        for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {
          newPopulation.push(this.getOffspring());
        }
        this.population = newPopulation;
        this.mutate();
        this.population.push(...elitists);
        for (i = 0; i < this.population.length; i++) {
          this.population[i].score = void 0;
        }
        this.generation++;
        return fittest;
      },
      getOffspring: function() {
        var parent1 = this.getParent();
        var parent2 = this.getParent();
        return Network.crossOver(parent1, parent2, this.equal);
      },
      selectMutationMethod: function(genome) {
        var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];
        if (mutationMethod === methods.mutation.ADD_NODE && genome.nodes.length >= this.maxNodes) {
          if (config.warnings)
            console.warn("maxNodes exceeded!");
          return;
        }
        if (mutationMethod === methods.mutation.ADD_CONN && genome.connections.length >= this.maxConns) {
          if (config.warnings)
            console.warn("maxConns exceeded!");
          return;
        }
        if (mutationMethod === methods.mutation.ADD_GATE && genome.gates.length >= this.maxGates) {
          if (config.warnings)
            console.warn("maxGates exceeded!");
          return;
        }
        return mutationMethod;
      },
      mutate: function() {
        for (var i = 0; i < this.population.length; i++) {
          if (Math.random() <= this.mutationRate) {
            for (var j = 0; j < this.mutationAmount; j++) {
              var mutationMethod = this.selectMutationMethod(this.population[i]);
              this.population[i].mutate(mutationMethod);
            }
          }
        }
      },
      evaluate: async function() {
        var i;
        if (this.fitnessPopulation) {
          if (this.clear) {
            for (i = 0; i < this.population.length; i++) {
              this.population[i].clear();
            }
          }
          await this.fitness(this.population);
        } else {
          for (i = 0; i < this.population.length; i++) {
            var genome = this.population[i];
            if (this.clear)
              genome.clear();
            genome.score = await this.fitness(genome);
          }
        }
      },
      sort: function() {
        this.population.sort(function(a, b) {
          return b.score - a.score;
        });
      },
      getFittest: function() {
        if (typeof this.population[this.population.length - 1].score === "undefined") {
          this.evaluate();
        }
        if (this.population[0].score < this.population[1].score) {
          this.sort();
        }
        return this.population[0];
      },
      getAverage: function() {
        if (typeof this.population[this.population.length - 1].score === "undefined") {
          this.evaluate();
        }
        var score = 0;
        for (var i = 0; i < this.population.length; i++) {
          score += this.population[i].score;
        }
        return score / this.population.length;
      },
      getParent: function() {
        var i;
        switch (this.selection) {
          case selection.POWER:
            if (this.population[0].score < this.population[1].score)
              this.sort();
            var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);
            return this.population[index];
          case selection.FITNESS_PROPORTIONATE:
            var totalFitness = 0;
            var minimalFitness = 0;
            for (i = 0; i < this.population.length; i++) {
              var score = this.population[i].score;
              minimalFitness = score < minimalFitness ? score : minimalFitness;
              totalFitness += score;
            }
            minimalFitness = Math.abs(minimalFitness);
            totalFitness += minimalFitness * this.population.length;
            var random = Math.random() * totalFitness;
            var value = 0;
            for (i = 0; i < this.population.length; i++) {
              let genome = this.population[i];
              value += genome.score + minimalFitness;
              if (random < value)
                return genome;
            }
            return this.population[Math.floor(Math.random() * this.population.length)];
          case selection.TOURNAMENT:
            if (this.selection.size > this.popsize) {
              throw new Error("Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size");
            }
            var individuals = [];
            for (i = 0; i < this.selection.size; i++) {
              let random2 = this.population[Math.floor(Math.random() * this.population.length)];
              individuals.push(random2);
            }
            individuals.sort(function(a, b) {
              return b.score - a.score;
            });
            for (i = 0; i < this.selection.size; i++) {
              if (Math.random() < this.selection.probability || i === this.selection.size - 1) {
                return individuals[i];
              }
            }
        }
      },
      export: function() {
        var json = [];
        for (var i = 0; i < this.population.length; i++) {
          var genome = this.population[i];
          json.push(genome.toJSON());
        }
        return json;
      },
      import: function(json) {
        var population = [];
        for (var i = 0; i < json.length; i++) {
          var genome = json[i];
          population.push(Network.fromJSON(genome));
        }
        this.population = population;
        this.popsize = population.length;
      }
    };
  }
});

// node_modules/neataptic/src/architecture/node.js
var require_node = __commonJS({
  "node_modules/neataptic/src/architecture/node.js"(exports, module) {
    module.exports = Node;
    var methods = require_methods();
    var Connection = require_connection2();
    var config = require_config();
    function Node(type) {
      this.bias = type === "input" ? 0 : Math.random() * 0.2 - 0.1;
      this.squash = methods.activation.LOGISTIC;
      this.type = type || "hidden";
      this.activation = 0;
      this.state = 0;
      this.old = 0;
      this.mask = 1;
      this.previousDeltaBias = 0;
      this.totalDeltaBias = 0;
      this.connections = {
        in: [],
        out: [],
        gated: [],
        self: new Connection(this, this, 0)
      };
      this.error = {
        responsibility: 0,
        projected: 0,
        gated: 0
      };
    }
    Node.prototype = {
      activate: function(input) {
        if (typeof input !== "undefined") {
          this.activation = input;
          return this.activation;
        }
        this.old = this.state;
        this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;
        var i;
        for (i = 0; i < this.connections.in.length; i++) {
          var connection = this.connections.in[i];
          this.state += connection.from.activation * connection.weight * connection.gain;
        }
        this.activation = this.squash(this.state) * this.mask;
        this.derivative = this.squash(this.state, true);
        var nodes = [];
        var influences = [];
        for (i = 0; i < this.connections.gated.length; i++) {
          let conn = this.connections.gated[i];
          let node = conn.to;
          let index = nodes.indexOf(node);
          if (index > -1) {
            influences[index] += conn.weight * conn.from.activation;
          } else {
            nodes.push(node);
            influences.push(conn.weight * conn.from.activation + (node.connections.self.gater === this ? node.old : 0));
          }
          conn.gain = this.activation;
        }
        for (i = 0; i < this.connections.in.length; i++) {
          let connection2 = this.connections.in[i];
          connection2.elegibility = this.connections.self.gain * this.connections.self.weight * connection2.elegibility + connection2.from.activation * connection2.gain;
          for (var j = 0; j < nodes.length; j++) {
            let node = nodes[j];
            let influence = influences[j];
            let index = connection2.xtrace.nodes.indexOf(node);
            if (index > -1) {
              connection2.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight * connection2.xtrace.values[index] + this.derivative * connection2.elegibility * influence;
            } else {
              connection2.xtrace.nodes.push(node);
              connection2.xtrace.values.push(this.derivative * connection2.elegibility * influence);
            }
          }
        }
        return this.activation;
      },
      noTraceActivate: function(input) {
        if (typeof input !== "undefined") {
          this.activation = input;
          return this.activation;
        }
        this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;
        var i;
        for (i = 0; i < this.connections.in.length; i++) {
          var connection = this.connections.in[i];
          this.state += connection.from.activation * connection.weight * connection.gain;
        }
        this.activation = this.squash(this.state);
        for (i = 0; i < this.connections.gated.length; i++) {
          this.connections.gated[i].gain = this.activation;
        }
        return this.activation;
      },
      propagate: function(rate, momentum, update, target) {
        momentum = momentum || 0;
        rate = rate || 0.3;
        var error = 0;
        if (this.type === "output") {
          this.error.responsibility = this.error.projected = target - this.activation;
        } else {
          var i;
          for (i = 0; i < this.connections.out.length; i++) {
            let connection = this.connections.out[i];
            let node = connection.to;
            error += node.error.responsibility * connection.weight * connection.gain;
          }
          this.error.projected = this.derivative * error;
          error = 0;
          for (i = 0; i < this.connections.gated.length; i++) {
            let conn = this.connections.gated[i];
            let node = conn.to;
            let influence = node.connections.self.gater === this ? node.old : 0;
            influence += conn.weight * conn.from.activation;
            error += node.error.responsibility * influence;
          }
          this.error.gated = this.derivative * error;
          this.error.responsibility = this.error.projected + this.error.gated;
        }
        if (this.type === "constant")
          return;
        for (i = 0; i < this.connections.in.length; i++) {
          let connection = this.connections.in[i];
          let gradient = this.error.projected * connection.elegibility;
          for (var j = 0; j < connection.xtrace.nodes.length; j++) {
            let node = connection.xtrace.nodes[j];
            let value = connection.xtrace.values[j];
            gradient += node.error.responsibility * value;
          }
          let deltaWeight = rate * gradient * this.mask;
          connection.totalDeltaWeight += deltaWeight;
          if (update) {
            connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;
            connection.weight += connection.totalDeltaWeight;
            connection.previousDeltaWeight = connection.totalDeltaWeight;
            connection.totalDeltaWeight = 0;
          }
        }
        var deltaBias = rate * this.error.responsibility;
        this.totalDeltaBias += deltaBias;
        if (update) {
          this.totalDeltaBias += momentum * this.previousDeltaBias;
          this.bias += this.totalDeltaBias;
          this.previousDeltaBias = this.totalDeltaBias;
          this.totalDeltaBias = 0;
        }
      },
      connect: function(target, weight) {
        var connections = [];
        if (typeof target.bias !== "undefined") {
          if (target === this) {
            if (this.connections.self.weight !== 0) {
              if (config.warnings)
                console.warn("This connection already exists!");
            } else {
              this.connections.self.weight = weight || 1;
            }
            connections.push(this.connections.self);
          } else if (this.isProjectingTo(target)) {
            throw new Error("Already projecting a connection to this node!");
          } else {
            let connection = new Connection(this, target, weight);
            target.connections.in.push(connection);
            this.connections.out.push(connection);
            connections.push(connection);
          }
        } else {
          for (var i = 0; i < target.nodes.length; i++) {
            let connection = new Connection(this, target.nodes[i], weight);
            target.nodes[i].connections.in.push(connection);
            this.connections.out.push(connection);
            target.connections.in.push(connection);
            connections.push(connection);
          }
        }
        return connections;
      },
      disconnect: function(node, twosided) {
        if (this === node) {
          this.connections.self.weight = 0;
          return;
        }
        for (var i = 0; i < this.connections.out.length; i++) {
          let conn = this.connections.out[i];
          if (conn.to === node) {
            this.connections.out.splice(i, 1);
            let j = conn.to.connections.in.indexOf(conn);
            conn.to.connections.in.splice(j, 1);
            if (conn.gater !== null)
              conn.gater.ungate(conn);
            break;
          }
        }
        if (twosided) {
          node.disconnect(this);
        }
      },
      gate: function(connections) {
        if (!Array.isArray(connections)) {
          connections = [connections];
        }
        for (var i = 0; i < connections.length; i++) {
          var connection = connections[i];
          this.connections.gated.push(connection);
          connection.gater = this;
        }
      },
      ungate: function(connections) {
        if (!Array.isArray(connections)) {
          connections = [connections];
        }
        for (var i = connections.length - 1; i >= 0; i--) {
          var connection = connections[i];
          var index = this.connections.gated.indexOf(connection);
          this.connections.gated.splice(index, 1);
          connection.gater = null;
          connection.gain = 1;
        }
      },
      clear: function() {
        for (var i = 0; i < this.connections.in.length; i++) {
          var connection = this.connections.in[i];
          connection.elegibility = 0;
          connection.xtrace = {
            nodes: [],
            values: []
          };
        }
        for (i = 0; i < this.connections.gated.length; i++) {
          let conn = this.connections.gated[i];
          conn.gain = 0;
        }
        this.error.responsibility = this.error.projected = this.error.gated = 0;
        this.old = this.state = this.activation = 0;
      },
      mutate: function(method) {
        if (typeof method === "undefined") {
          throw new Error("No mutate method given!");
        } else if (!(method.name in methods.mutation)) {
          throw new Error("This method does not exist!");
        }
        switch (method) {
          case methods.mutation.MOD_ACTIVATION:
            var squash = method.allowed[(method.allowed.indexOf(this.squash) + Math.floor(Math.random() * (method.allowed.length - 1)) + 1) % method.allowed.length];
            this.squash = squash;
            break;
          case methods.mutation.MOD_BIAS:
            var modification = Math.random() * (method.max - method.min) + method.min;
            this.bias += modification;
            break;
        }
      },
      isProjectingTo: function(node) {
        if (node === this && this.connections.self.weight !== 0)
          return true;
        for (var i = 0; i < this.connections.out.length; i++) {
          var conn = this.connections.out[i];
          if (conn.to === node) {
            return true;
          }
        }
        return false;
      },
      isProjectedBy: function(node) {
        if (node === this && this.connections.self.weight !== 0)
          return true;
        for (var i = 0; i < this.connections.in.length; i++) {
          var conn = this.connections.in[i];
          if (conn.from === node) {
            return true;
          }
        }
        return false;
      },
      toJSON: function() {
        var json = {
          bias: this.bias,
          type: this.type,
          squash: this.squash.name,
          mask: this.mask
        };
        return json;
      }
    };
    Node.fromJSON = function(json) {
      var node = new Node();
      node.bias = json.bias;
      node.type = json.type;
      node.mask = json.mask;
      node.squash = methods.activation[json.squash];
      return node;
    };
  }
});

// browser-external:os
var os_exports = {};
__export(os_exports, {
  default: () => os_default
});
var os_default;
var init_os = __esm({
  "browser-external:os"() {
    os_default = new Proxy({}, {
      get() {
        throw new Error('Module "os" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/neataptic/src/architecture/network.js
var require_network = __commonJS({
  "node_modules/neataptic/src/architecture/network.js"(exports, module) {
    module.exports = Network;
    var multi = require_multi();
    var methods = require_methods();
    var Connection = require_connection2();
    var config = require_config();
    var Neat = require_neat();
    var Node = require_node();
    var mutation = methods.mutation;
    function Network(input, output) {
      if (typeof input === "undefined" || typeof output === "undefined") {
        throw new Error("No input or output size given");
      }
      this.input = input;
      this.output = output;
      this.nodes = [];
      this.connections = [];
      this.gates = [];
      this.selfconns = [];
      this.dropout = 0;
      var i;
      for (i = 0; i < this.input + this.output; i++) {
        var type = i < this.input ? "input" : "output";
        this.nodes.push(new Node(type));
      }
      for (i = 0; i < this.input; i++) {
        for (var j = this.input; j < this.output + this.input; j++) {
          var weight = Math.random() * this.input * Math.sqrt(2 / this.input);
          this.connect(this.nodes[i], this.nodes[j], weight);
        }
      }
    }
    Network.prototype = {
      activate: function(input, training) {
        var output = [];
        for (var i = 0; i < this.nodes.length; i++) {
          if (this.nodes[i].type === "input") {
            this.nodes[i].activate(input[i]);
          } else if (this.nodes[i].type === "output") {
            var activation = this.nodes[i].activate();
            output.push(activation);
          } else {
            if (training)
              this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;
            this.nodes[i].activate();
          }
        }
        return output;
      },
      noTraceActivate: function(input) {
        var output = [];
        for (var i = 0; i < this.nodes.length; i++) {
          if (this.nodes[i].type === "input") {
            this.nodes[i].noTraceActivate(input[i]);
          } else if (this.nodes[i].type === "output") {
            var activation = this.nodes[i].noTraceActivate();
            output.push(activation);
          } else {
            this.nodes[i].noTraceActivate();
          }
        }
        return output;
      },
      propagate: function(rate, momentum, update, target) {
        if (typeof target === "undefined" || target.length !== this.output) {
          throw new Error("Output target length should match network output length");
        }
        var targetIndex = target.length;
        var i;
        for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {
          this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);
        }
        for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {
          this.nodes[i].propagate(rate, momentum, update);
        }
      },
      clear: function() {
        for (var i = 0; i < this.nodes.length; i++) {
          this.nodes[i].clear();
        }
      },
      connect: function(from, to, weight) {
        var connections = from.connect(to, weight);
        for (var i = 0; i < connections.length; i++) {
          var connection = connections[i];
          if (from !== to) {
            this.connections.push(connection);
          } else {
            this.selfconns.push(connection);
          }
        }
        return connections;
      },
      disconnect: function(from, to) {
        var connections = from === to ? this.selfconns : this.connections;
        for (var i = 0; i < connections.length; i++) {
          var connection = connections[i];
          if (connection.from === from && connection.to === to) {
            if (connection.gater !== null)
              this.ungate(connection);
            connections.splice(i, 1);
            break;
          }
        }
        from.disconnect(to);
      },
      gate: function(node, connection) {
        if (this.nodes.indexOf(node) === -1) {
          throw new Error("This node is not part of the network!");
        } else if (connection.gater != null) {
          if (config.warnings)
            console.warn("This connection is already gated!");
          return;
        }
        node.gate(connection);
        this.gates.push(connection);
      },
      ungate: function(connection) {
        var index = this.gates.indexOf(connection);
        if (index === -1) {
          throw new Error("This connection is not gated!");
        }
        this.gates.splice(index, 1);
        connection.gater.ungate(connection);
      },
      remove: function(node) {
        var index = this.nodes.indexOf(node);
        if (index === -1) {
          throw new Error("This node does not exist in the network!");
        }
        var gaters = [];
        this.disconnect(node, node);
        var inputs = [];
        for (var i = node.connections.in.length - 1; i >= 0; i--) {
          let connection = node.connections.in[i];
          if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {
            gaters.push(connection.gater);
          }
          inputs.push(connection.from);
          this.disconnect(connection.from, node);
        }
        var outputs = [];
        for (i = node.connections.out.length - 1; i >= 0; i--) {
          let connection = node.connections.out[i];
          if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {
            gaters.push(connection.gater);
          }
          outputs.push(connection.to);
          this.disconnect(node, connection.to);
        }
        var connections = [];
        for (i = 0; i < inputs.length; i++) {
          let input = inputs[i];
          for (var j = 0; j < outputs.length; j++) {
            let output = outputs[j];
            if (!input.isProjectingTo(output)) {
              var conn = this.connect(input, output);
              connections.push(conn[0]);
            }
          }
        }
        for (i = 0; i < gaters.length; i++) {
          if (connections.length === 0)
            break;
          let gater = gaters[i];
          let connIndex = Math.floor(Math.random() * connections.length);
          this.gate(gater, connections[connIndex]);
          connections.splice(connIndex, 1);
        }
        for (i = node.connections.gated.length - 1; i >= 0; i--) {
          let conn2 = node.connections.gated[i];
          this.ungate(conn2);
        }
        this.disconnect(node, node);
        this.nodes.splice(index, 1);
      },
      mutate: function(method) {
        if (typeof method === "undefined") {
          throw new Error("No (correct) mutate method given!");
        }
        var i, j;
        switch (method) {
          case mutation.ADD_NODE:
            var connection = this.connections[Math.floor(Math.random() * this.connections.length)];
            var gater = connection.gater;
            this.disconnect(connection.from, connection.to);
            var toIndex = this.nodes.indexOf(connection.to);
            var node = new Node("hidden");
            node.mutate(mutation.MOD_ACTIVATION);
            var minBound = Math.min(toIndex, this.nodes.length - this.output);
            this.nodes.splice(minBound, 0, node);
            var newConn1 = this.connect(connection.from, node)[0];
            var newConn2 = this.connect(node, connection.to)[0];
            if (gater != null) {
              this.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);
            }
            break;
          case mutation.SUB_NODE:
            if (this.nodes.length === this.input + this.output) {
              if (config.warnings)
                console.warn("No more nodes left to remove!");
              break;
            }
            var index = Math.floor(Math.random() * (this.nodes.length - this.output - this.input) + this.input);
            this.remove(this.nodes[index]);
            break;
          case mutation.ADD_CONN:
            var available = [];
            for (i = 0; i < this.nodes.length - this.output; i++) {
              let node12 = this.nodes[i];
              for (j = Math.max(i + 1, this.input); j < this.nodes.length; j++) {
                let node22 = this.nodes[j];
                if (!node12.isProjectingTo(node22))
                  available.push([node12, node22]);
              }
            }
            if (available.length === 0) {
              if (config.warnings)
                console.warn("No more connections to be made!");
              break;
            }
            var pair = available[Math.floor(Math.random() * available.length)];
            this.connect(pair[0], pair[1]);
            break;
          case mutation.SUB_CONN:
            var possible = [];
            for (i = 0; i < this.connections.length; i++) {
              let conn2 = this.connections[i];
              if (conn2.from.connections.out.length > 1 && conn2.to.connections.in.length > 1 && this.nodes.indexOf(conn2.to) > this.nodes.indexOf(conn2.from)) {
                possible.push(conn2);
              }
            }
            if (possible.length === 0) {
              if (config.warnings)
                console.warn("No connections to remove!");
              break;
            }
            var randomConn = possible[Math.floor(Math.random() * possible.length)];
            this.disconnect(randomConn.from, randomConn.to);
            break;
          case mutation.MOD_WEIGHT:
            var allconnections = this.connections.concat(this.selfconns);
            var connection = allconnections[Math.floor(Math.random() * allconnections.length)];
            var modification = Math.random() * (method.max - method.min) + method.min;
            connection.weight += modification;
            break;
          case mutation.MOD_BIAS:
            var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);
            var node = this.nodes[index];
            node.mutate(method);
            break;
          case mutation.MOD_ACTIVATION:
            if (!method.mutateOutput && this.input + this.output === this.nodes.length) {
              if (config.warnings)
                console.warn("No nodes that allow mutation of activation function");
              break;
            }
            var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
            var node = this.nodes[index];
            node.mutate(method);
            break;
          case mutation.ADD_SELF_CONN:
            var possible = [];
            for (i = this.input; i < this.nodes.length; i++) {
              let node3 = this.nodes[i];
              if (node3.connections.self.weight === 0) {
                possible.push(node3);
              }
            }
            if (possible.length === 0) {
              if (config.warnings)
                console.warn("No more self-connections to add!");
              break;
            }
            var node = possible[Math.floor(Math.random() * possible.length)];
            this.connect(node, node);
            break;
          case mutation.SUB_SELF_CONN:
            if (this.selfconns.length === 0) {
              if (config.warnings)
                console.warn("No more self-connections to remove!");
              break;
            }
            var conn = this.selfconns[Math.floor(Math.random() * this.selfconns.length)];
            this.disconnect(conn.from, conn.to);
            break;
          case mutation.ADD_GATE:
            var allconnections = this.connections.concat(this.selfconns);
            var possible = [];
            for (i = 0; i < allconnections.length; i++) {
              let conn2 = allconnections[i];
              if (conn2.gater === null) {
                possible.push(conn2);
              }
            }
            if (possible.length === 0) {
              if (config.warnings)
                console.warn("No more connections to gate!");
              break;
            }
            var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);
            var node = this.nodes[index];
            var conn = possible[Math.floor(Math.random() * possible.length)];
            this.gate(node, conn);
            break;
          case mutation.SUB_GATE:
            if (this.gates.length === 0) {
              if (config.warnings)
                console.warn("No more connections to ungate!");
              break;
            }
            var index = Math.floor(Math.random() * this.gates.length);
            var gatedconn = this.gates[index];
            this.ungate(gatedconn);
            break;
          case mutation.ADD_BACK_CONN:
            var available = [];
            for (i = this.input; i < this.nodes.length; i++) {
              let node12 = this.nodes[i];
              for (j = this.input; j < i; j++) {
                let node22 = this.nodes[j];
                if (!node12.isProjectingTo(node22))
                  available.push([node12, node22]);
              }
            }
            if (available.length === 0) {
              if (config.warnings)
                console.warn("No more connections to be made!");
              break;
            }
            var pair = available[Math.floor(Math.random() * available.length)];
            this.connect(pair[0], pair[1]);
            break;
          case mutation.SUB_BACK_CONN:
            var possible = [];
            for (i = 0; i < this.connections.length; i++) {
              let conn2 = this.connections[i];
              if (conn2.from.connections.out.length > 1 && conn2.to.connections.in.length > 1 && this.nodes.indexOf(conn2.from) > this.nodes.indexOf(conn2.to)) {
                possible.push(conn2);
              }
            }
            if (possible.length === 0) {
              if (config.warnings)
                console.warn("No connections to remove!");
              break;
            }
            var randomConn = possible[Math.floor(Math.random() * possible.length)];
            this.disconnect(randomConn.from, randomConn.to);
            break;
          case mutation.SWAP_NODES:
            if (method.mutateOutput && this.nodes.length - this.input < 2 || !method.mutateOutput && this.nodes.length - this.input - this.output < 2) {
              if (config.warnings)
                console.warn("No nodes that allow swapping of bias and activation function");
              break;
            }
            var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
            var node1 = this.nodes[index];
            index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);
            var node2 = this.nodes[index];
            var biasTemp = node1.bias;
            var squashTemp = node1.squash;
            node1.bias = node2.bias;
            node1.squash = node2.squash;
            node2.bias = biasTemp;
            node2.squash = squashTemp;
            break;
        }
      },
      train: function(set, options) {
        if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
          throw new Error("Dataset input/output size should be same as network input/output size!");
        }
        options = options || {};
        if (typeof options.rate === "undefined") {
          if (config.warnings)
            console.warn("Using default learning rate, please define a rate!");
        }
        if (typeof options.iterations === "undefined") {
          if (config.warnings)
            console.warn("No target iterations given, running until error is reached!");
        }
        var targetError = options.error || 0.05;
        var cost = options.cost || methods.cost.MSE;
        var baseRate = options.rate || 0.3;
        var dropout = options.dropout || 0;
        var momentum = options.momentum || 0;
        var batchSize = options.batchSize || 1;
        var ratePolicy = options.ratePolicy || methods.rate.FIXED();
        var start = Date.now();
        if (batchSize > set.length) {
          throw new Error("Batch size must be smaller or equal to dataset length!");
        } else if (typeof options.iterations === "undefined" && typeof options.error === "undefined") {
          throw new Error("At least one of the following options must be specified: error, iterations");
        } else if (typeof options.error === "undefined") {
          targetError = -1;
        } else if (typeof options.iterations === "undefined") {
          options.iterations = 0;
        }
        this.dropout = dropout;
        if (options.crossValidate) {
          let numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);
          var trainSet = set.slice(0, numTrain);
          var testSet = set.slice(numTrain);
        }
        var currentRate = baseRate;
        var iteration = 0;
        var error = 1;
        var i, j, x;
        while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {
          if (options.crossValidate && error <= options.crossValidate.testError)
            break;
          iteration++;
          currentRate = ratePolicy(baseRate, iteration);
          if (options.crossValidate) {
            this._trainSet(trainSet, batchSize, currentRate, momentum, cost);
            if (options.clear)
              this.clear();
            error = this.test(testSet, cost).error;
            if (options.clear)
              this.clear();
          } else {
            error = this._trainSet(set, batchSize, currentRate, momentum, cost);
            if (options.clear)
              this.clear();
          }
          if (options.shuffle) {
            for (j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x)
              ;
          }
          if (options.log && iteration % options.log === 0) {
            console.log("iteration", iteration, "error", error, "rate", currentRate);
          }
          if (options.schedule && iteration % options.schedule.iterations === 0) {
            options.schedule.function({ error, iteration });
          }
        }
        if (options.clear)
          this.clear();
        if (dropout) {
          for (i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].type === "hidden" || this.nodes[i].type === "constant") {
              this.nodes[i].mask = 1 - this.dropout;
            }
          }
        }
        return {
          error,
          iterations: iteration,
          time: Date.now() - start
        };
      },
      _trainSet: function(set, batchSize, currentRate, momentum, costFunction) {
        var errorSum = 0;
        for (var i = 0; i < set.length; i++) {
          var input = set[i].input;
          var target = set[i].output;
          var update = !!((i + 1) % batchSize === 0 || i + 1 === set.length);
          var output = this.activate(input, true);
          this.propagate(currentRate, momentum, update, target);
          errorSum += costFunction(target, output);
        }
        return errorSum / set.length;
      },
      test: function(set, cost = methods.cost.MSE) {
        var i;
        if (this.dropout) {
          for (i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].type === "hidden" || this.nodes[i].type === "constant") {
              this.nodes[i].mask = 1 - this.dropout;
            }
          }
        }
        var error = 0;
        var start = Date.now();
        for (i = 0; i < set.length; i++) {
          let input = set[i].input;
          let target = set[i].output;
          let output = this.noTraceActivate(input);
          error += cost(target, output);
        }
        error /= set.length;
        var results = {
          error,
          time: Date.now() - start
        };
        return results;
      },
      graph: function(width, height) {
        var input = 0;
        var output = 0;
        var json = {
          nodes: [],
          links: [],
          constraints: [{
            type: "alignment",
            axis: "x",
            offsets: []
          }, {
            type: "alignment",
            axis: "y",
            offsets: []
          }]
        };
        var i;
        for (i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          if (node.type === "input") {
            if (this.input === 1) {
              json.constraints[0].offsets.push({
                node: i,
                offset: 0
              });
            } else {
              json.constraints[0].offsets.push({
                node: i,
                offset: 0.8 * width / (this.input - 1) * input++
              });
            }
            json.constraints[1].offsets.push({
              node: i,
              offset: 0
            });
          } else if (node.type === "output") {
            if (this.output === 1) {
              json.constraints[0].offsets.push({
                node: i,
                offset: 0
              });
            } else {
              json.constraints[0].offsets.push({
                node: i,
                offset: 0.8 * width / (this.output - 1) * output++
              });
            }
            json.constraints[1].offsets.push({
              node: i,
              offset: -0.8 * height
            });
          }
          json.nodes.push({
            id: i,
            name: node.type === "hidden" ? node.squash.name : node.type.toUpperCase(),
            activation: node.activation,
            bias: node.bias
          });
        }
        var connections = this.connections.concat(this.selfconns);
        for (i = 0; i < connections.length; i++) {
          var connection = connections[i];
          if (connection.gater == null) {
            json.links.push({
              source: this.nodes.indexOf(connection.from),
              target: this.nodes.indexOf(connection.to),
              weight: connection.weight
            });
          } else {
            var index = json.nodes.length;
            json.nodes.push({
              id: index,
              activation: connection.gater.activation,
              name: "GATE"
            });
            json.links.push({
              source: this.nodes.indexOf(connection.from),
              target: index,
              weight: 1 / 2 * connection.weight
            });
            json.links.push({
              source: index,
              target: this.nodes.indexOf(connection.to),
              weight: 1 / 2 * connection.weight
            });
            json.links.push({
              source: this.nodes.indexOf(connection.gater),
              target: index,
              weight: connection.gater.activation,
              gate: true
            });
          }
        }
        return json;
      },
      toJSON: function() {
        var json = {
          nodes: [],
          connections: [],
          input: this.input,
          output: this.output,
          dropout: this.dropout
        };
        var i;
        for (i = 0; i < this.nodes.length; i++) {
          this.nodes[i].index = i;
        }
        for (i = 0; i < this.nodes.length; i++) {
          let node = this.nodes[i];
          let tojson = node.toJSON();
          tojson.index = i;
          json.nodes.push(tojson);
          if (node.connections.self.weight !== 0) {
            let tojson2 = node.connections.self.toJSON();
            tojson2.from = i;
            tojson2.to = i;
            tojson2.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;
            json.connections.push(tojson2);
          }
        }
        for (i = 0; i < this.connections.length; i++) {
          let conn = this.connections[i];
          let tojson = conn.toJSON();
          tojson.from = conn.from.index;
          tojson.to = conn.to.index;
          tojson.gater = conn.gater != null ? conn.gater.index : null;
          json.connections.push(tojson);
        }
        return json;
      },
      set: function(values) {
        for (var i = 0; i < this.nodes.length; i++) {
          this.nodes[i].bias = values.bias || this.nodes[i].bias;
          this.nodes[i].squash = values.squash || this.nodes[i].squash;
        }
      },
      evolve: async function(set, options) {
        if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
          throw new Error("Dataset input/output size should be same as network input/output size!");
        }
        options = options || {};
        var targetError = typeof options.error !== "undefined" ? options.error : 0.05;
        var growth = typeof options.growth !== "undefined" ? options.growth : 1e-4;
        var cost = options.cost || methods.cost.MSE;
        var amount = options.amount || 1;
        var threads = options.threads;
        if (typeof threads === "undefined") {
          if (typeof window === "undefined") {
            threads = (init_os(), os_exports).cpus().length;
          } else {
            threads = navigator.hardwareConcurrency;
          }
        }
        var start = Date.now();
        if (typeof options.iterations === "undefined" && typeof options.error === "undefined") {
          throw new Error("At least one of the following options must be specified: error, iterations");
        } else if (typeof options.error === "undefined") {
          targetError = -1;
        } else if (typeof options.iterations === "undefined") {
          options.iterations = 0;
        }
        var fitnessFunction;
        if (threads === 1) {
          fitnessFunction = function(genome) {
            var score = 0;
            for (var i2 = 0; i2 < amount; i2++) {
              score -= genome.test(set, cost).error;
            }
            score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;
            score = isNaN(score) ? -Infinity : score;
            return score / amount;
          };
        } else {
          var converted = multi.serializeDataSet(set);
          var workers = [];
          if (typeof window === "undefined") {
            for (var i = 0; i < threads; i++) {
              workers.push(new multi.workers.node.TestWorker(converted, cost));
            }
          } else {
            for (var i = 0; i < threads; i++) {
              workers.push(new multi.workers.browser.TestWorker(converted, cost));
            }
          }
          fitnessFunction = function(population) {
            return new Promise((resolve, reject) => {
              var queue = population.slice();
              var done = 0;
              var startWorker = function(worker) {
                if (!queue.length) {
                  if (++done === threads)
                    resolve();
                  return;
                }
                var genome = queue.shift();
                worker.evaluate(genome).then(function(result) {
                  genome.score = -result;
                  genome.score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;
                  genome.score = isNaN(parseFloat(result)) ? -Infinity : genome.score;
                  startWorker(worker);
                });
              };
              for (var i2 = 0; i2 < workers.length; i2++) {
                startWorker(workers[i2]);
              }
            });
          };
          options.fitnessPopulation = true;
        }
        options.network = this;
        var neat = new Neat(this.input, this.output, fitnessFunction, options);
        var error = -Infinity;
        var bestFitness = -Infinity;
        var bestGenome;
        while (error < -targetError && (options.iterations === 0 || neat.generation < options.iterations)) {
          let fittest = await neat.evolve();
          let fitness = fittest.score;
          error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;
          if (fitness > bestFitness) {
            bestFitness = fitness;
            bestGenome = fittest;
          }
          if (options.log && neat.generation % options.log === 0) {
            console.log("iteration", neat.generation, "fitness", fitness, "error", -error);
          }
          if (options.schedule && neat.generation % options.schedule.iterations === 0) {
            options.schedule.function({ fitness, error: -error, iteration: neat.generation });
          }
        }
        if (threads > 1) {
          for (var i = 0; i < workers.length; i++)
            workers[i].terminate();
        }
        if (typeof bestGenome !== "undefined") {
          this.nodes = bestGenome.nodes;
          this.connections = bestGenome.connections;
          this.selfconns = bestGenome.selfconns;
          this.gates = bestGenome.gates;
          if (options.clear)
            this.clear();
        }
        return {
          error: -error,
          iterations: neat.generation,
          time: Date.now() - start
        };
      },
      standalone: function() {
        var present = [];
        var activations = [];
        var states = [];
        var lines = [];
        var functions = [];
        var i;
        for (i = 0; i < this.input; i++) {
          var node = this.nodes[i];
          activations.push(node.activation);
          states.push(node.state);
        }
        lines.push("for(var i = 0; i < input.length; i++) A[i] = input[i];");
        for (i = 0; i < this.nodes.length; i++) {
          this.nodes[i].index = i;
        }
        for (i = this.input; i < this.nodes.length; i++) {
          let node2 = this.nodes[i];
          activations.push(node2.activation);
          states.push(node2.state);
          var functionIndex = present.indexOf(node2.squash.name);
          if (functionIndex === -1) {
            functionIndex = present.length;
            present.push(node2.squash.name);
            functions.push(node2.squash.toString());
          }
          var incoming = [];
          for (var j = 0; j < node2.connections.in.length; j++) {
            var conn = node2.connections.in[j];
            var computation = `A[${conn.from.index}] * ${conn.weight}`;
            if (conn.gater != null) {
              computation += ` * A[${conn.gater.index}]`;
            }
            incoming.push(computation);
          }
          if (node2.connections.self.weight) {
            let conn2 = node2.connections.self;
            let computation2 = `S[${i}] * ${conn2.weight}`;
            if (conn2.gater != null) {
              computation2 += ` * A[${conn2.gater.index}]`;
            }
            incoming.push(computation2);
          }
          var line1 = `S[${i}] = ${incoming.join(" + ")} + ${node2.bias};`;
          var line2 = `A[${i}] = F[${functionIndex}](S[${i}])${!node2.mask ? " * " + node2.mask : ""};`;
          lines.push(line1);
          lines.push(line2);
        }
        var output = [];
        for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {
          output.push(`A[${i}]`);
        }
        output = `return [${output.join(",")}];`;
        lines.push(output);
        var total = "";
        total += `var F = [${functions.toString()}];\r
`;
        total += `var A = [${activations.toString()}];\r
`;
        total += `var S = [${states.toString()}];\r
`;
        total += `function activate(input){\r
${lines.join("\r\n")}\r
}`;
        return total;
      },
      serialize: function() {
        var activations = [];
        var states = [];
        var conns = [];
        var squashes = [
          "LOGISTIC",
          "TANH",
          "IDENTITY",
          "STEP",
          "RELU",
          "SOFTSIGN",
          "SINUSOID",
          "GAUSSIAN",
          "BENT_IDENTITY",
          "BIPOLAR",
          "BIPOLAR_SIGMOID",
          "HARD_TANH",
          "ABSOLUTE",
          "INVERSE",
          "SELU"
        ];
        conns.push(this.input);
        conns.push(this.output);
        var i;
        for (i = 0; i < this.nodes.length; i++) {
          let node = this.nodes[i];
          node.index = i;
          activations.push(node.activation);
          states.push(node.state);
        }
        for (i = this.input; i < this.nodes.length; i++) {
          let node = this.nodes[i];
          conns.push(node.index);
          conns.push(node.bias);
          conns.push(squashes.indexOf(node.squash.name));
          conns.push(node.connections.self.weight);
          conns.push(node.connections.self.gater == null ? -1 : node.connections.self.gater.index);
          for (var j = 0; j < node.connections.in.length; j++) {
            let conn = node.connections.in[j];
            conns.push(conn.from.index);
            conns.push(conn.weight);
            conns.push(conn.gater == null ? -1 : conn.gater.index);
          }
          conns.push(-2);
        }
        return [activations, states, conns];
      }
    };
    Network.fromJSON = function(json) {
      var network = new Network(json.input, json.output);
      network.dropout = json.dropout;
      network.nodes = [];
      network.connections = [];
      var i;
      for (i = 0; i < json.nodes.length; i++) {
        network.nodes.push(Node.fromJSON(json.nodes[i]));
      }
      for (i = 0; i < json.connections.length; i++) {
        var conn = json.connections[i];
        var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];
        connection.weight = conn.weight;
        if (conn.gater != null) {
          network.gate(network.nodes[conn.gater], connection);
        }
      }
      return network;
    };
    Network.merge = function(network1, network2) {
      network1 = Network.fromJSON(network1.toJSON());
      network2 = Network.fromJSON(network2.toJSON());
      if (network1.output !== network2.input) {
        throw new Error("Output size of network1 should be the same as the input size of network2!");
      }
      var i;
      for (i = 0; i < network2.connections.length; i++) {
        let conn = network2.connections[i];
        if (conn.from.type === "input") {
          let index = network2.nodes.indexOf(conn.from);
          conn.from = network1.nodes[network1.nodes.length - 1 - index];
        }
      }
      for (i = network2.input - 1; i >= 0; i--) {
        network2.nodes.splice(i, 1);
      }
      for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {
        network1.nodes[i].type = "hidden";
      }
      network1.connections = network1.connections.concat(network2.connections);
      network1.nodes = network1.nodes.concat(network2.nodes);
      return network1;
    };
    Network.crossOver = function(network1, network2, equal) {
      if (network1.input !== network2.input || network1.output !== network2.output) {
        throw new Error("Networks don't have the same input/output size!");
      }
      var offspring = new Network(network1.input, network1.output);
      offspring.connections = [];
      offspring.nodes = [];
      var score1 = network1.score || 0;
      var score2 = network2.score || 0;
      var size;
      if (equal || score1 === score2) {
        let max = Math.max(network1.nodes.length, network2.nodes.length);
        let min = Math.min(network1.nodes.length, network2.nodes.length);
        size = Math.floor(Math.random() * (max - min + 1) + min);
      } else if (score1 > score2) {
        size = network1.nodes.length;
      } else {
        size = network2.nodes.length;
      }
      var outputSize = network1.output;
      var i;
      for (i = 0; i < network1.nodes.length; i++) {
        network1.nodes[i].index = i;
      }
      for (i = 0; i < network2.nodes.length; i++) {
        network2.nodes[i].index = i;
      }
      for (i = 0; i < size; i++) {
        var node;
        if (i < size - outputSize) {
          let random = Math.random();
          node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];
          let other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];
          if (typeof node === "undefined" || node.type === "output") {
            node = other;
          }
        } else {
          if (Math.random() >= 0.5) {
            node = network1.nodes[network1.nodes.length + i - size];
          } else {
            node = network2.nodes[network2.nodes.length + i - size];
          }
        }
        var newNode = new Node();
        newNode.bias = node.bias;
        newNode.squash = node.squash;
        newNode.type = node.type;
        offspring.nodes.push(newNode);
      }
      var n1conns = {};
      var n2conns = {};
      for (i = 0; i < network1.connections.length; i++) {
        let conn = network1.connections[i];
        let data = {
          weight: conn.weight,
          from: conn.from.index,
          to: conn.to.index,
          gater: conn.gater != null ? conn.gater.index : -1
        };
        n1conns[Connection.innovationID(data.from, data.to)] = data;
      }
      for (i = 0; i < network1.selfconns.length; i++) {
        let conn = network1.selfconns[i];
        let data = {
          weight: conn.weight,
          from: conn.from.index,
          to: conn.to.index,
          gater: conn.gater != null ? conn.gater.index : -1
        };
        n1conns[Connection.innovationID(data.from, data.to)] = data;
      }
      for (i = 0; i < network2.connections.length; i++) {
        let conn = network2.connections[i];
        let data = {
          weight: conn.weight,
          from: conn.from.index,
          to: conn.to.index,
          gater: conn.gater != null ? conn.gater.index : -1
        };
        n2conns[Connection.innovationID(data.from, data.to)] = data;
      }
      for (i = 0; i < network2.selfconns.length; i++) {
        let conn = network2.selfconns[i];
        let data = {
          weight: conn.weight,
          from: conn.from.index,
          to: conn.to.index,
          gater: conn.gater != null ? conn.gater.index : -1
        };
        n2conns[Connection.innovationID(data.from, data.to)] = data;
      }
      var connections = [];
      var keys1 = Object.keys(n1conns);
      var keys2 = Object.keys(n2conns);
      for (i = keys1.length - 1; i >= 0; i--) {
        if (typeof n2conns[keys1[i]] !== "undefined") {
          let conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];
          connections.push(conn);
          n2conns[keys1[i]] = void 0;
        } else if (score1 >= score2 || equal) {
          connections.push(n1conns[keys1[i]]);
        }
      }
      if (score2 >= score1 || equal) {
        for (i = 0; i < keys2.length; i++) {
          if (typeof n2conns[keys2[i]] !== "undefined") {
            connections.push(n2conns[keys2[i]]);
          }
        }
      }
      for (i = 0; i < connections.length; i++) {
        let connData = connections[i];
        if (connData.to < size && connData.from < size) {
          let from = offspring.nodes[connData.from];
          let to = offspring.nodes[connData.to];
          let conn = offspring.connect(from, to)[0];
          conn.weight = connData.weight;
          if (connData.gater !== -1 && connData.gater < size) {
            offspring.gate(offspring.nodes[connData.gater], conn);
          }
        }
      }
      return offspring;
    };
  }
});

// node_modules/neataptic/src/architecture/layer.js
var require_layer = __commonJS({
  "node_modules/neataptic/src/architecture/layer.js"(exports, module) {
    module.exports = Layer;
    var methods = require_methods();
    var Group = require_group();
    var Node = require_node();
    function Layer() {
      this.output = null;
      this.nodes = [];
      this.connections = {
        in: [],
        out: [],
        self: []
      };
    }
    Layer.prototype = {
      activate: function(value) {
        var values = [];
        if (typeof value !== "undefined" && value.length !== this.nodes.length) {
          throw new Error("Array with values should be same as the amount of nodes!");
        }
        for (var i = 0; i < this.nodes.length; i++) {
          var activation;
          if (typeof value === "undefined") {
            activation = this.nodes[i].activate();
          } else {
            activation = this.nodes[i].activate(value[i]);
          }
          values.push(activation);
        }
        return values;
      },
      propagate: function(rate, momentum, target) {
        if (typeof target !== "undefined" && target.length !== this.nodes.length) {
          throw new Error("Array with values should be same as the amount of nodes!");
        }
        for (var i = this.nodes.length - 1; i >= 0; i--) {
          if (typeof target === "undefined") {
            this.nodes[i].propagate(rate, momentum, true);
          } else {
            this.nodes[i].propagate(rate, momentum, true, target[i]);
          }
        }
      },
      connect: function(target, method, weight) {
        var connections;
        if (target instanceof Group || target instanceof Node) {
          connections = this.output.connect(target, method, weight);
        } else if (target instanceof Layer) {
          connections = target.input(this, method, weight);
        }
        return connections;
      },
      gate: function(connections, method) {
        this.output.gate(connections, method);
      },
      set: function(values) {
        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          if (node instanceof Node) {
            if (typeof values.bias !== "undefined") {
              node.bias = values.bias;
            }
            node.squash = values.squash || node.squash;
            node.type = values.type || node.type;
          } else if (node instanceof Group) {
            node.set(values);
          }
        }
      },
      disconnect: function(target, twosided) {
        twosided = twosided || false;
        var i, j, k;
        if (target instanceof Group) {
          for (i = 0; i < this.nodes.length; i++) {
            for (j = 0; j < target.nodes.length; j++) {
              this.nodes[i].disconnect(target.nodes[j], twosided);
              for (k = this.connections.out.length - 1; k >= 0; k--) {
                let conn = this.connections.out[k];
                if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {
                  this.connections.out.splice(k, 1);
                  break;
                }
              }
              if (twosided) {
                for (k = this.connections.in.length - 1; k >= 0; k--) {
                  let conn = this.connections.in[k];
                  if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {
                    this.connections.in.splice(k, 1);
                    break;
                  }
                }
              }
            }
          }
        } else if (target instanceof Node) {
          for (i = 0; i < this.nodes.length; i++) {
            this.nodes[i].disconnect(target, twosided);
            for (j = this.connections.out.length - 1; j >= 0; j--) {
              let conn = this.connections.out[j];
              if (conn.from === this.nodes[i] && conn.to === target) {
                this.connections.out.splice(j, 1);
                break;
              }
            }
            if (twosided) {
              for (k = this.connections.in.length - 1; k >= 0; k--) {
                let conn = this.connections.in[k];
                if (conn.from === target && conn.to === this.nodes[i]) {
                  this.connections.in.splice(k, 1);
                  break;
                }
              }
            }
          }
        }
      },
      clear: function() {
        for (var i = 0; i < this.nodes.length; i++) {
          this.nodes[i].clear();
        }
      }
    };
    Layer.Dense = function(size) {
      var layer = new Layer();
      var block = new Group(size);
      layer.nodes.push(block);
      layer.output = block;
      layer.input = function(from, method, weight) {
        if (from instanceof Layer)
          from = from.output;
        method = method || methods.connection.ALL_TO_ALL;
        return from.connect(block, method, weight);
      };
      return layer;
    };
    Layer.LSTM = function(size) {
      var layer = new Layer();
      var inputGate = new Group(size);
      var forgetGate = new Group(size);
      var memoryCell = new Group(size);
      var outputGate = new Group(size);
      var outputBlock = new Group(size);
      inputGate.set({
        bias: 1
      });
      forgetGate.set({
        bias: 1
      });
      outputGate.set({
        bias: 1
      });
      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);
      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);
      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);
      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);
      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);
      forgetGate.gate(forget, methods.gating.SELF);
      outputGate.gate(output, methods.gating.OUTPUT);
      layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];
      layer.output = outputBlock;
      layer.input = function(from, method, weight) {
        if (from instanceof Layer)
          from = from.output;
        method = method || methods.connection.ALL_TO_ALL;
        var connections = [];
        var input = from.connect(memoryCell, method, weight);
        connections = connections.concat(input);
        connections = connections.concat(from.connect(inputGate, method, weight));
        connections = connections.concat(from.connect(outputGate, method, weight));
        connections = connections.concat(from.connect(forgetGate, method, weight));
        inputGate.gate(input, methods.gating.INPUT);
        return connections;
      };
      return layer;
    };
    Layer.GRU = function(size) {
      var layer = new Layer();
      var updateGate = new Group(size);
      var inverseUpdateGate = new Group(size);
      var resetGate = new Group(size);
      var memoryCell = new Group(size);
      var output = new Group(size);
      var previousOutput = new Group(size);
      previousOutput.set({
        bias: 0,
        squash: methods.activation.IDENTITY,
        type: "constant"
      });
      memoryCell.set({
        squash: methods.activation.TANH
      });
      inverseUpdateGate.set({
        bias: 0,
        squash: methods.activation.INVERSE,
        type: "constant"
      });
      updateGate.set({
        bias: 1
      });
      resetGate.set({
        bias: 0
      });
      previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL);
      updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1);
      previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL);
      var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);
      resetGate.gate(reset, methods.gating.OUTPUT);
      var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);
      var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);
      updateGate.gate(update1, methods.gating.OUTPUT);
      inverseUpdateGate.gate(update2, methods.gating.OUTPUT);
      output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1);
      layer.nodes = [updateGate, inverseUpdateGate, resetGate, memoryCell, output, previousOutput];
      layer.output = output;
      layer.input = function(from, method, weight) {
        if (from instanceof Layer)
          from = from.output;
        method = method || methods.connection.ALL_TO_ALL;
        var connections = [];
        connections = connections.concat(from.connect(updateGate, method, weight));
        connections = connections.concat(from.connect(resetGate, method, weight));
        connections = connections.concat(from.connect(memoryCell, method, weight));
        return connections;
      };
      return layer;
    };
    Layer.Memory = function(size, memory) {
      var layer = new Layer();
      var previous = null;
      var i;
      for (i = 0; i < memory; i++) {
        var block = new Group(size);
        block.set({
          squash: methods.activation.IDENTITY,
          bias: 0,
          type: "constant"
        });
        if (previous != null) {
          previous.connect(block, methods.connection.ONE_TO_ONE, 1);
        }
        layer.nodes.push(block);
        previous = block;
      }
      layer.nodes.reverse();
      for (i = 0; i < layer.nodes.length; i++) {
        layer.nodes[i].nodes.reverse();
      }
      var outputGroup = new Group(0);
      for (var group in layer.nodes) {
        outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);
      }
      layer.output = outputGroup;
      layer.input = function(from, method, weight) {
        if (from instanceof Layer)
          from = from.output;
        method = method || methods.connection.ALL_TO_ALL;
        if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {
          throw new Error("Previous layer size must be same as memory size");
        }
        return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);
      };
      return layer;
    };
  }
});

// node_modules/neataptic/src/architecture/group.js
var require_group = __commonJS({
  "node_modules/neataptic/src/architecture/group.js"(exports, module) {
    module.exports = Group;
    var methods = require_methods();
    var config = require_config();
    var Layer = require_layer();
    var Node = require_node();
    function Group(size) {
      this.nodes = [];
      this.connections = {
        in: [],
        out: [],
        self: []
      };
      for (var i = 0; i < size; i++) {
        this.nodes.push(new Node());
      }
    }
    Group.prototype = {
      activate: function(value) {
        var values = [];
        if (typeof value !== "undefined" && value.length !== this.nodes.length) {
          throw new Error("Array with values should be same as the amount of nodes!");
        }
        for (var i = 0; i < this.nodes.length; i++) {
          var activation;
          if (typeof value === "undefined") {
            activation = this.nodes[i].activate();
          } else {
            activation = this.nodes[i].activate(value[i]);
          }
          values.push(activation);
        }
        return values;
      },
      propagate: function(rate, momentum, target) {
        if (typeof target !== "undefined" && target.length !== this.nodes.length) {
          throw new Error("Array with values should be same as the amount of nodes!");
        }
        for (var i = this.nodes.length - 1; i >= 0; i--) {
          if (typeof target === "undefined") {
            this.nodes[i].propagate(rate, momentum, true);
          } else {
            this.nodes[i].propagate(rate, momentum, true, target[i]);
          }
        }
      },
      connect: function(target, method, weight) {
        var connections = [];
        var i, j;
        if (target instanceof Group) {
          if (typeof method === "undefined") {
            if (this !== target) {
              if (config.warnings)
                console.warn("No group connection specified, using ALL_TO_ALL");
              method = methods.connection.ALL_TO_ALL;
            } else {
              if (config.warnings)
                console.warn("No group connection specified, using ONE_TO_ONE");
              method = methods.connection.ONE_TO_ONE;
            }
          }
          if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {
            for (i = 0; i < this.nodes.length; i++) {
              for (j = 0; j < target.nodes.length; j++) {
                if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j])
                  continue;
                let connection = this.nodes[i].connect(target.nodes[j], weight);
                this.connections.out.push(connection[0]);
                target.connections.in.push(connection[0]);
                connections.push(connection[0]);
              }
            }
          } else if (method === methods.connection.ONE_TO_ONE) {
            if (this.nodes.length !== target.nodes.length) {
              throw new Error("From and To group must be the same size!");
            }
            for (i = 0; i < this.nodes.length; i++) {
              let connection = this.nodes[i].connect(target.nodes[i], weight);
              this.connections.self.push(connection[0]);
              connections.push(connection[0]);
            }
          }
        } else if (target instanceof Layer) {
          connections = target.input(this, method, weight);
        } else if (target instanceof Node) {
          for (i = 0; i < this.nodes.length; i++) {
            let connection = this.nodes[i].connect(target, weight);
            this.connections.out.push(connection[0]);
            connections.push(connection[0]);
          }
        }
        return connections;
      },
      gate: function(connections, method) {
        if (typeof method === "undefined") {
          throw new Error("Please specify Gating.INPUT, Gating.OUTPUT");
        }
        if (!Array.isArray(connections)) {
          connections = [connections];
        }
        var nodes1 = [];
        var nodes2 = [];
        var i, j;
        for (i = 0; i < connections.length; i++) {
          var connection = connections[i];
          if (!nodes1.includes(connection.from))
            nodes1.push(connection.from);
          if (!nodes2.includes(connection.to))
            nodes2.push(connection.to);
        }
        switch (method) {
          case methods.gating.INPUT:
            for (i = 0; i < nodes2.length; i++) {
              let node = nodes2[i];
              let gater = this.nodes[i % this.nodes.length];
              for (j = 0; j < node.connections.in.length; j++) {
                let conn = node.connections.in[j];
                if (connections.includes(conn)) {
                  gater.gate(conn);
                }
              }
            }
            break;
          case methods.gating.OUTPUT:
            for (i = 0; i < nodes1.length; i++) {
              let node = nodes1[i];
              let gater = this.nodes[i % this.nodes.length];
              for (j = 0; j < node.connections.out.length; j++) {
                let conn = node.connections.out[j];
                if (connections.includes(conn)) {
                  gater.gate(conn);
                }
              }
            }
            break;
          case methods.gating.SELF:
            for (i = 0; i < nodes1.length; i++) {
              let node = nodes1[i];
              let gater = this.nodes[i % this.nodes.length];
              if (connections.includes(node.connections.self)) {
                gater.gate(node.connections.self);
              }
            }
        }
      },
      set: function(values) {
        for (var i = 0; i < this.nodes.length; i++) {
          if (typeof values.bias !== "undefined") {
            this.nodes[i].bias = values.bias;
          }
          this.nodes[i].squash = values.squash || this.nodes[i].squash;
          this.nodes[i].type = values.type || this.nodes[i].type;
        }
      },
      disconnect: function(target, twosided) {
        twosided = twosided || false;
        var i, j, k;
        if (target instanceof Group) {
          for (i = 0; i < this.nodes.length; i++) {
            for (j = 0; j < target.nodes.length; j++) {
              this.nodes[i].disconnect(target.nodes[j], twosided);
              for (k = this.connections.out.length - 1; k >= 0; k--) {
                let conn2 = this.connections.out[k];
                if (conn2.from === this.nodes[i] && conn2.to === target.nodes[j]) {
                  this.connections.out.splice(k, 1);
                  break;
                }
              }
              if (twosided) {
                for (k = this.connections.in.length - 1; k >= 0; k--) {
                  let conn2 = this.connections.in[k];
                  if (conn2.from === target.nodes[j] && conn2.to === this.nodes[i]) {
                    this.connections.in.splice(k, 1);
                    break;
                  }
                }
              }
            }
          }
        } else if (target instanceof Node) {
          for (i = 0; i < this.nodes.length; i++) {
            this.nodes[i].disconnect(target, twosided);
            for (j = this.connections.out.length - 1; j >= 0; j--) {
              let conn2 = this.connections.out[j];
              if (conn2.from === this.nodes[i] && conn2.to === target) {
                this.connections.out.splice(j, 1);
                break;
              }
            }
            if (twosided) {
              for (j = this.connections.in.length - 1; j >= 0; j--) {
                var conn = this.connections.in[j];
                if (conn.from === target && conn.to === this.nodes[i]) {
                  this.connections.in.splice(j, 1);
                  break;
                }
              }
            }
          }
        }
      },
      clear: function() {
        for (var i = 0; i < this.nodes.length; i++) {
          this.nodes[i].clear();
        }
      }
    };
  }
});

// node_modules/neataptic/src/architecture/architect.js
var require_architect = __commonJS({
  "node_modules/neataptic/src/architecture/architect.js"(exports, module) {
    var methods = require_methods();
    var Network = require_network();
    var Group = require_group();
    var Layer = require_layer();
    var Node = require_node();
    var architect = {
      Construct: function(list) {
        var network = new Network(0, 0);
        var nodes = [];
        var i;
        for (i = 0; i < list.length; i++) {
          let j;
          if (list[i] instanceof Group) {
            for (j = 0; j < list[i].nodes.length; j++) {
              nodes.push(list[i].nodes[j]);
            }
          } else if (list[i] instanceof Layer) {
            for (j = 0; j < list[i].nodes.length; j++) {
              for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {
                nodes.push(list[i].nodes[j].nodes[k]);
              }
            }
          } else if (list[i] instanceof Node) {
            nodes.push(list[i]);
          }
        }
        var inputs = [];
        var outputs = [];
        for (i = nodes.length - 1; i >= 0; i--) {
          if (nodes[i].type === "output" || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {
            nodes[i].type = "output";
            network.output++;
            outputs.push(nodes[i]);
            nodes.splice(i, 1);
          } else if (nodes[i].type === "input" || !nodes[i].connections.in.length) {
            nodes[i].type = "input";
            network.input++;
            inputs.push(nodes[i]);
            nodes.splice(i, 1);
          }
        }
        nodes = inputs.concat(nodes).concat(outputs);
        if (network.input === 0 || network.output === 0) {
          throw new Error("Given nodes have no clear input/output node!");
        }
        for (i = 0; i < nodes.length; i++) {
          let j;
          for (j = 0; j < nodes[i].connections.out.length; j++) {
            network.connections.push(nodes[i].connections.out[j]);
          }
          for (j = 0; j < nodes[i].connections.gated.length; j++) {
            network.gates.push(nodes[i].connections.gated[j]);
          }
          if (nodes[i].connections.self.weight !== 0) {
            network.selfconns.push(nodes[i].connections.self);
          }
        }
        network.nodes = nodes;
        return network;
      },
      Perceptron: function() {
        var layers = Array.prototype.slice.call(arguments);
        if (layers.length < 3) {
          throw new Error("You have to specify at least 3 layers");
        }
        var nodes = [];
        nodes.push(new Group(layers[0]));
        for (var i = 1; i < layers.length; i++) {
          var layer = layers[i];
          layer = new Group(layer);
          nodes.push(layer);
          nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);
        }
        return architect.Construct(nodes);
      },
      Random: function(input, hidden, output, options) {
        options = options || {};
        var connections = options.connections || hidden * 2;
        var backconnections = options.backconnections || 0;
        var selfconnections = options.selfconnections || 0;
        var gates = options.gates || 0;
        var network = new Network(input, output);
        var i;
        for (i = 0; i < hidden; i++) {
          network.mutate(methods.mutation.ADD_NODE);
        }
        for (i = 0; i < connections - hidden; i++) {
          network.mutate(methods.mutation.ADD_CONN);
        }
        for (i = 0; i < backconnections; i++) {
          network.mutate(methods.mutation.ADD_BACK_CONN);
        }
        for (i = 0; i < selfconnections; i++) {
          network.mutate(methods.mutation.ADD_SELF_CONN);
        }
        for (i = 0; i < gates; i++) {
          network.mutate(methods.mutation.ADD_GATE);
        }
        return network;
      },
      LSTM: function() {
        var args = Array.prototype.slice.call(arguments);
        if (args.length < 3) {
          throw new Error("You have to specify at least 3 layers");
        }
        var last = args.pop();
        var outputLayer;
        if (typeof last === "number") {
          outputLayer = new Group(last);
          last = {};
        } else {
          outputLayer = new Group(args.pop());
        }
        outputLayer.set({
          type: "output"
        });
        var options = {};
        options.memoryToMemory = last.memoryToMemory || false;
        options.outputToMemory = last.outputToMemory || false;
        options.outputToGates = last.outputToGates || false;
        options.inputToOutput = last.inputToOutput === void 0 ? true : last.inputToOutput;
        options.inputToDeep = last.inputToDeep === void 0 ? true : last.inputToDeep;
        var inputLayer = new Group(args.shift());
        inputLayer.set({
          type: "input"
        });
        var blocks = args;
        var nodes = [];
        nodes.push(inputLayer);
        var previous = inputLayer;
        for (var i = 0; i < blocks.length; i++) {
          var block = blocks[i];
          var inputGate = new Group(block);
          var forgetGate = new Group(block);
          var memoryCell = new Group(block);
          var outputGate = new Group(block);
          var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block);
          inputGate.set({
            bias: 1
          });
          forgetGate.set({
            bias: 1
          });
          outputGate.set({
            bias: 1
          });
          var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL);
          previous.connect(inputGate, methods.connection.ALL_TO_ALL);
          previous.connect(outputGate, methods.connection.ALL_TO_ALL);
          previous.connect(forgetGate, methods.connection.ALL_TO_ALL);
          memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);
          memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);
          memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);
          var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);
          var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);
          inputGate.gate(input, methods.gating.INPUT);
          forgetGate.gate(forget, methods.gating.SELF);
          outputGate.gate(output, methods.gating.OUTPUT);
          if (options.inputToDeep && i > 0) {
            let input2 = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);
            inputGate.gate(input2, methods.gating.INPUT);
          }
          if (options.memoryToMemory) {
            let input2 = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE);
            inputGate.gate(input2, methods.gating.INPUT);
          }
          if (options.outputToMemory) {
            let input2 = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);
            inputGate.gate(input2, methods.gating.INPUT);
          }
          if (options.outputToGates) {
            outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL);
            outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL);
            outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL);
          }
          nodes.push(inputGate);
          nodes.push(forgetGate);
          nodes.push(memoryCell);
          nodes.push(outputGate);
          if (i !== blocks.length - 1)
            nodes.push(outputBlock);
          previous = outputBlock;
        }
        if (options.inputToOutput) {
          inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL);
        }
        nodes.push(outputLayer);
        return architect.Construct(nodes);
      },
      GRU: function() {
        var args = Array.prototype.slice.call(arguments);
        if (args.length < 3) {
          throw new Error("not enough layers (minimum 3) !!");
        }
        var inputLayer = new Group(args.shift());
        var outputLayer = new Group(args.pop());
        var blocks = args;
        var nodes = [];
        nodes.push(inputLayer);
        var previous = inputLayer;
        for (var i = 0; i < blocks.length; i++) {
          var layer = new Layer.GRU(blocks[i]);
          previous.connect(layer);
          previous = layer;
          nodes.push(layer);
        }
        previous.connect(outputLayer);
        nodes.push(outputLayer);
        return architect.Construct(nodes);
      },
      Hopfield: function(size) {
        var input = new Group(size);
        var output = new Group(size);
        input.connect(output, methods.connection.ALL_TO_ALL);
        input.set({
          type: "input"
        });
        output.set({
          squash: methods.activation.STEP,
          type: "output"
        });
        var network = new architect.Construct([input, output]);
        return network;
      },
      NARX: function(inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {
        if (!Array.isArray(hiddenLayers)) {
          hiddenLayers = [hiddenLayers];
        }
        var nodes = [];
        var input = new Layer.Dense(inputSize);
        var inputMemory = new Layer.Memory(inputSize, previousInput);
        var hidden = [];
        var output = new Layer.Dense(outputSize);
        var outputMemory = new Layer.Memory(outputSize, previousOutput);
        nodes.push(input);
        nodes.push(outputMemory);
        for (var i = 0; i < hiddenLayers.length; i++) {
          var hiddenLayer = new Layer.Dense(hiddenLayers[i]);
          hidden.push(hiddenLayer);
          nodes.push(hiddenLayer);
          if (typeof hidden[i - 1] !== "undefined") {
            hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);
          }
        }
        nodes.push(inputMemory);
        nodes.push(output);
        input.connect(hidden[0], methods.connection.ALL_TO_ALL);
        input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);
        inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);
        hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);
        output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);
        outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);
        input.set({
          type: "input"
        });
        output.set({
          type: "output"
        });
        return architect.Construct(nodes);
      }
    };
    module.exports = architect;
  }
});

// node_modules/neataptic/src/neataptic.js
var require_neataptic = __commonJS({
  "node_modules/neataptic/src/neataptic.js"(exports, module) {
    var Neataptic = {
      methods: require_methods(),
      Connection: require_connection2(),
      architect: require_architect(),
      Network: require_network(),
      config: require_config(),
      Group: require_group(),
      Layer: require_layer(),
      Node: require_node(),
      Neat: require_neat(),
      multi: require_multi()
    };
    if (typeof define !== "undefined" && define.amd) {
      define([], function() {
        return Neataptic;
      });
    }
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Neataptic;
    }
    if (typeof window === "object") {
      (function() {
        var old = window["neataptic"];
        Neataptic.ninja = function() {
          window["neataptic"] = old;
          return Neataptic;
        };
      })();
      window["neataptic"] = Neataptic;
    }
  }
});

// dep:neataptic
var neataptic_default = require_neataptic();
export {
  neataptic_default as default
};
//# sourceMappingURL=neataptic.js.map
