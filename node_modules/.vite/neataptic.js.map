{
  "version": 3,
  "sources": ["../neataptic/src/methods/activation.js", "../neataptic/src/methods/mutation.js", "../neataptic/src/methods/selection.js", "../neataptic/src/methods/crossover.js", "../neataptic/src/methods/cost.js", "../neataptic/src/methods/gating.js", "../neataptic/src/methods/connection.js", "../neataptic/src/methods/rate.js", "../neataptic/src/methods/methods.js", "../neataptic/src/architecture/connection.js", "browser-external:child_process", "browser-external:path", "../neataptic/src/multithreading/workers/node/testworker.js", "../neataptic/src/multithreading/workers/browser/testworker.js", "../neataptic/src/multithreading/workers/workers.js", "../neataptic/src/multithreading/multi.js", "../neataptic/src/config.js", "../neataptic/src/neat.js", "../neataptic/src/architecture/node.js", "browser-external:os", "../neataptic/src/architecture/network.js", "../neataptic/src/architecture/layer.js", "../neataptic/src/architecture/group.js", "../neataptic/src/architecture/architect.js", "../neataptic/src/neataptic.js", "dep:neataptic"],
  "sourcesContent": ["/*******************************************************************************\r\n                                  ACTIVATION FUNCTIONS\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Activation_function\r\n// https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons\r\nvar activation = {\r\n  LOGISTIC: function (x, derivate) {\r\n    var fx = 1 / (1 + Math.exp(-x));\r\n    if (!derivate) return fx;\r\n    return fx * (1 - fx);\r\n  },\r\n  TANH: function (x, derivate) {\r\n    if (derivate) return 1 - Math.pow(Math.tanh(x), 2);\r\n    return Math.tanh(x);\r\n  },\r\n  IDENTITY: function (x, derivate) {\r\n    return derivate ? 1 : x;\r\n  },\r\n  STEP: function (x, derivate) {\r\n    return derivate ? 0 : x > 0 ? 1 : 0;\r\n  },\r\n  RELU: function (x, derivate) {\r\n    if (derivate) return x > 0 ? 1 : 0;\r\n    return x > 0 ? x : 0;\r\n  },\r\n  SOFTSIGN: function (x, derivate) {\r\n    var d = 1 + Math.abs(x);\r\n    if (derivate) return x / Math.pow(d, 2);\r\n    return x / d;\r\n  },\r\n  SINUSOID: function (x, derivate) {\r\n    if (derivate) return Math.cos(x);\r\n    return Math.sin(x);\r\n  },\r\n  GAUSSIAN: function (x, derivate) {\r\n    var d = Math.exp(-Math.pow(x, 2));\r\n    if (derivate) return -2 * x * d;\r\n    return d;\r\n  },\r\n  BENT_IDENTITY: function (x, derivate) {\r\n    var d = Math.sqrt(Math.pow(x, 2) + 1);\r\n    if (derivate) return x / (2 * d) + 1;\r\n    return (d - 1) / 2 + x;\r\n  },\r\n  BIPOLAR: function (x, derivate) {\r\n    return derivate ? 0 : x > 0 ? 1 : -1;\r\n  },\r\n  BIPOLAR_SIGMOID: function (x, derivate) {\r\n    var d = 2 / (1 + Math.exp(-x)) - 1;\r\n    if (derivate) return 1 / 2 * (1 + d) * (1 - d);\r\n    return d;\r\n  },\r\n  HARD_TANH: function (x, derivate) {\r\n    if (derivate) return x > -1 && x < 1 ? 1 : 0;\r\n    return Math.max(-1, Math.min(1, x));\r\n  },\r\n  ABSOLUTE: function (x, derivate) {\r\n    if (derivate) return x < 0 ? -1 : 1;\r\n    return Math.abs(x);\r\n  },\r\n  INVERSE: function (x, derivate) {\r\n    if (derivate) return -1;\r\n    return 1 - x;\r\n  },\r\n  // https://arxiv.org/pdf/1706.02515.pdf\r\n  SELU: function (x, derivate) {\r\n    var alpha = 1.6732632423543772848170429916717;\r\n    var scale = 1.0507009873554804934193349852946;\r\n    var fx = x > 0 ? x : alpha * Math.exp(x) - alpha;\r\n    if (derivate) { return x > 0 ? scale : (fx + alpha) * scale; }\r\n    return fx * scale;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = activation;\r\n", "/* Import */\r\nvar activation = require('./activation');\r\n\r\n/*******************************************************************************\r\n                                      MUTATION\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/mutation_(genetic_algorithm)\r\nvar mutation = {\r\n  ADD_NODE: {\r\n    name: 'ADD_NODE'\r\n  },\r\n  SUB_NODE: {\r\n    name: 'SUB_NODE',\r\n    keep_gates: true\r\n  },\r\n  ADD_CONN: {\r\n    name: 'ADD_CONN'\r\n  },\r\n  SUB_CONN: {\r\n    name: 'REMOVE_CONN'\r\n  },\r\n  MOD_WEIGHT: {\r\n    name: 'MOD_WEIGHT',\r\n    min: -1,\r\n    max: 1\r\n  },\r\n  MOD_BIAS: {\r\n    name: 'MOD_BIAS',\r\n    min: -1,\r\n    max: 1\r\n  },\r\n  MOD_ACTIVATION: {\r\n    name: 'MOD_ACTIVATION',\r\n    mutateOutput: true,\r\n    allowed: [\r\n      activation.LOGISTIC,\r\n      activation.TANH,\r\n      activation.RELU,\r\n      activation.IDENTITY,\r\n      activation.STEP,\r\n      activation.SOFTSIGN,\r\n      activation.SINUSOID,\r\n      activation.GAUSSIAN,\r\n      activation.BENT_IDENTITY,\r\n      activation.BIPOLAR,\r\n      activation.BIPOLAR_SIGMOID,\r\n      activation.HARD_TANH,\r\n      activation.ABSOLUTE,\r\n      activation.INVERSE,\r\n      activation.SELU\r\n    ]\r\n  },\r\n  ADD_SELF_CONN: {\r\n    name: 'ADD_SELF_CONN'\r\n  },\r\n  SUB_SELF_CONN: {\r\n    name: 'SUB_SELF_CONN'\r\n  },\r\n  ADD_GATE: {\r\n    name: 'ADD_GATE'\r\n  },\r\n  SUB_GATE: {\r\n    name: 'SUB_GATE'\r\n  },\r\n  ADD_BACK_CONN: {\r\n    name: 'ADD_BACK_CONN'\r\n  },\r\n  SUB_BACK_CONN: {\r\n    name: 'SUB_BACK_CONN'\r\n  },\r\n  SWAP_NODES: {\r\n    name: 'SWAP_NODES',\r\n    mutateOutput: true\r\n  }\r\n};\r\n\r\nmutation.ALL = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.ADD_GATE,\r\n  mutation.SUB_GATE,\r\n  mutation.ADD_SELF_CONN,\r\n  mutation.SUB_SELF_CONN,\r\n  mutation.ADD_BACK_CONN,\r\n  mutation.SUB_BACK_CONN,\r\n  mutation.SWAP_NODES\r\n];\r\n\r\nmutation.FFW = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.SWAP_NODES\r\n];\r\n\r\n/* Export */\r\nmodule.exports = mutation;\r\n", "/*******************************************************************************\r\n                                      SELECTION\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)\r\n\r\nvar selection = {\r\n  FITNESS_PROPORTIONATE: {\r\n    name: 'FITNESS_PROPORTIONATE'\r\n  },\r\n  POWER: {\r\n    name: 'POWER',\r\n    power: 4\r\n  },\r\n  TOURNAMENT: {\r\n    name: 'TOURNAMENT',\r\n    size: 5,\r\n    probability: 0.5\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = selection;\r\n", "/*******************************************************************************\r\n                                      CROSSOVER\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\r\nvar crossover = {\r\n  SINGLE_POINT: {\r\n    name: 'SINGLE_POINT',\r\n    config: [0.4]\r\n  },\r\n  TWO_POINT: {\r\n    name: 'TWO_POINT',\r\n    config: [0.4, 0.9]\r\n  },\r\n  UNIFORM: {\r\n    name: 'UNIFORM'\r\n  },\r\n  AVERAGE: {\r\n    name: 'AVERAGE'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = crossover;\r\n", "/*******************************************************************************\r\n                                    COST FUNCTIONS\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Loss_function\r\nvar cost = {\r\n  // Cross entropy error\r\n  CROSS_ENTROPY: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A\r\n      error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));\r\n    }\r\n    return error / output.length;\r\n  },\r\n  // Mean Squared Error\r\n  MSE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.pow(target[i] - output[i], 2);\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Binary error\r\n  BINARY: function (target, output) {\r\n    var misses = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);\r\n    }\r\n\r\n    return misses;\r\n  },\r\n  // Mean Absolute Error\r\n  MAE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.abs(target[i] - output[i]);\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Mean Absolute Percentage Error\r\n  MAPE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Mean Squared Logarithmic Error\r\n  MSLE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));\r\n    }\r\n\r\n    return error;\r\n  },\r\n  // Hinge loss, for classifiers\r\n  HINGE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.max(0, 1 - target[i] * output[i]);\r\n    }\r\n\r\n    return error;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = cost;\r\n", "/*******************************************************************************\r\n                                    GATING\r\n*******************************************************************************/\r\n\r\n// Specifies how to gate a connection between two groups of multiple neurons\r\nvar gating = {\r\n  OUTPUT: {\r\n    name: 'OUTPUT'\r\n  },\r\n  INPUT: {\r\n    name: 'INPUT'\r\n  },\r\n  SELF: {\r\n    name: 'SELF'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = gating;\r\n", "/*******************************************************************************\r\n                                    CONNECTION\r\n*******************************************************************************/\r\n\r\n// Specifies in what manner two groups are connected\r\nvar connection = {\r\n  ALL_TO_ALL: {\r\n    name: 'OUTPUT'\r\n  },\r\n  ALL_TO_ELSE: {\r\n    name: 'INPUT'\r\n  },\r\n  ONE_TO_ONE: {\r\n    name: 'SELF'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = connection;\r\n", "/*******************************************************************************\r\n                                      RATE\r\n*******************************************************************************/\r\n\r\n// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244\r\nvar rate = {\r\n  FIXED: function () {\r\n    var func = function (baseRate, iteration) { return baseRate; };\r\n    return func;\r\n  },\r\n  STEP: function (gamma, stepSize) {\r\n    gamma = gamma || 0.9;\r\n    stepSize = stepSize || 100;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));\r\n    };\r\n\r\n    return func;\r\n  },\r\n  EXP: function (gamma) {\r\n    gamma = gamma || 0.999;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(gamma, iteration);\r\n    };\r\n\r\n    return func;\r\n  },\r\n  INV: function (gamma, power) {\r\n    gamma = gamma || 0.001;\r\n    power = power || 2;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(1 + gamma * iteration, -power);\r\n    };\r\n\r\n    return func;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = rate;\r\n", "/*******************************************************************************\r\n                                  METHODS\r\n*******************************************************************************/\r\n\r\nvar methods = {\r\n  activation: require('./activation'),\r\n  mutation: require('./mutation'),\r\n  selection: require('./selection'),\r\n  crossover: require('./crossover'),\r\n  cost: require('./cost'),\r\n  gating: require('./gating'),\r\n  connection: require('./connection'),\r\n  rate: require('./rate')\r\n};\r\n\r\n/** Export */\r\nmodule.exports = methods;\r\n", "/* Export */\r\nmodule.exports = Connection;\r\n\r\n/*******************************************************************************\r\n                                      CONNECTION\r\n*******************************************************************************/\r\n\r\nfunction Connection (from, to, weight) {\r\n  this.from = from;\r\n  this.to = to;\r\n  this.gain = 1;\r\n\r\n  this.weight = (typeof weight === 'undefined') ? Math.random() * 0.2 - 0.1 : weight;\r\n\r\n  this.gater = null;\r\n  this.elegibility = 0;\r\n\r\n  // For tracking momentum\r\n  this.previousDeltaWeight = 0;\r\n\r\n  // Batch training\r\n  this.totalDeltaWeight = 0;\r\n\r\n  this.xtrace = {\r\n    nodes: [],\r\n    values: []\r\n  };\r\n}\r\n\r\nConnection.prototype = {\r\n  /**\r\n   * Converts the connection to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      weight: this.weight\r\n    };\r\n\r\n    return json;\r\n  }\r\n};\r\n\r\n/**\r\n * Returns an innovation ID\r\n * https://en.wikipedia.org/wiki/Pairing_function (Cantor pairing function)\r\n */\r\nConnection.innovationID = function (a, b) {\r\n  return 1 / 2 * (a + b) * (a + b + 1) + b;\r\n};\r\n", "export default new Proxy({}, {\n  get() {\n    throw new Error('Module \"child_process\" has been externalized for browser compatibility and cannot be accessed in client code.')\n  }\n})", "export default new Proxy({}, {\n  get() {\n    throw new Error('Module \"path\" has been externalized for browser compatibility and cannot be accessed in client code.')\n  }\n})", "/* Export */\r\nmodule.exports = TestWorker;\r\n\r\n/* Import */\r\nvar cp = require('child_process');\r\nvar path = require('path');\r\n\r\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\r\n\r\nfunction TestWorker (dataSet, cost) {\r\n  this.worker = cp.fork(path.join(__dirname, '/worker'));\r\n\r\n  this.worker.send({ set: dataSet, cost: cost.name });\r\n}\r\n\r\nTestWorker.prototype = {\r\n  evaluate: function (network) {\r\n    return new Promise((resolve, reject) => {\r\n      var serialized = network.serialize();\r\n\r\n      var data = {\r\n        activations: serialized[0],\r\n        states: serialized[1],\r\n        conns: serialized[2]\r\n      };\r\n\r\n      var _that = this.worker;\r\n      this.worker.on('message', function callback (e) {\r\n        _that.removeListener('message', callback);\r\n        resolve(e);\r\n      });\r\n\r\n      this.worker.send(data);\r\n    });\r\n  },\r\n\r\n  terminate: function () {\r\n    this.worker.kill();\r\n  }\r\n};\r\n", "/* Export */\r\nmodule.exports = TestWorker;\r\n\r\n/* Import */\r\nvar multi = require('../../multi');\r\n\r\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\r\n\r\nfunction TestWorker (dataSet, cost) {\r\n  var blob = new Blob([this._createBlobString(cost)]);\r\n  this.url = window.URL.createObjectURL(blob);\r\n  this.worker = new Worker(this.url);\r\n\r\n  var data = { set: new Float64Array(dataSet).buffer };\r\n  this.worker.postMessage(data, [data.set]);\r\n}\r\n\r\nTestWorker.prototype = {\r\n  evaluate: function (network) {\r\n    return new Promise((resolve, reject) => {\r\n      var serialized = network.serialize();\r\n\r\n      var data = {\r\n        activations: new Float64Array(serialized[0]).buffer,\r\n        states: new Float64Array(serialized[1]).buffer,\r\n        conns: new Float64Array(serialized[2]).buffer\r\n      };\r\n\r\n      this.worker.onmessage = function (e) {\r\n        var error = new Float64Array(e.data.buffer)[0];\r\n        resolve(error);\r\n      };\r\n\r\n      this.worker.postMessage(data, [data.activations, data.states, data.conns]);\r\n    });\r\n  },\r\n\r\n  terminate: function () {\r\n    this.worker.terminate();\r\n    window.URL.revokeObjectURL(this.url);\r\n  },\r\n\r\n  _createBlobString: function (cost) {\r\n    var source = `\r\n      var F = [${multi.activations.toString()}];\r\n      var cost = ${cost.toString()};\r\n      var multi = {\r\n        deserializeDataSet: ${multi.deserializeDataSet.toString()},\r\n        testSerializedSet: ${multi.testSerializedSet.toString()},\r\n        activateSerializedNetwork: ${multi.activateSerializedNetwork.toString()}\r\n      };\r\n\r\n      this.onmessage = function (e) {\r\n        if(typeof e.data.set === 'undefined'){\r\n          var A = new Float64Array(e.data.activations);\r\n          var S = new Float64Array(e.data.states);\r\n          var data = new Float64Array(e.data.conns);\r\n\r\n          var error = multi.testSerializedSet(set, cost, A, S, data, F);\r\n\r\n          var answer = { buffer: new Float64Array([error ]).buffer };\r\n          postMessage(answer, [answer.buffer]);\r\n        } else {\r\n          set = multi.deserializeDataSet(new Float64Array(e.data.set));\r\n        }\r\n      };`;\r\n\r\n    return source;\r\n  }\r\n};\r\n", "/*******************************************************************************\r\n                                  WORKERS\r\n*******************************************************************************/\r\n\r\nvar workers = {\r\n  node: {\r\n    TestWorker: require('./node/testworker')\r\n  },\r\n  browser: {\r\n    TestWorker: require('./browser/testworker')\r\n  }\r\n};\r\n\r\n/** Export */\r\nmodule.exports = workers;\r\n", "/*******************************************************************************\r\n                                MULTITHREADING\r\n*******************************************************************************/\r\n\r\nvar multi = {\r\n  /** Workers */\r\n  workers: require('./workers/workers'),\r\n\r\n  /** Serializes a dataset */\r\n  serializeDataSet: function (dataSet) {\r\n    var serialized = [dataSet[0].input.length, dataSet[0].output.length];\r\n\r\n    for (var i = 0; i < dataSet.length; i++) {\r\n      var j;\r\n      for (j = 0; j < serialized[0]; j++) {\r\n        serialized.push(dataSet[i].input[j]);\r\n      }\r\n      for (j = 0; j < serialized[1]; j++) {\r\n        serialized.push(dataSet[i].output[j]);\r\n      }\r\n    }\r\n\r\n    return serialized;\r\n  },\r\n\r\n  /** Activate a serialized network */\r\n  activateSerializedNetwork: function (input, A, S, data, F) {\r\n    for (var i = 0; i < data[0]; i++) A[i] = input[i];\r\n    for (i = 2; i < data.length; i++) {\r\n      let index = data[i++];\r\n      let bias = data[i++];\r\n      let squash = data[i++];\r\n      let selfweight = data[i++];\r\n      let selfgater = data[i++];\r\n\r\n      S[index] = (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;\r\n\r\n      while (data[i] !== -2) {\r\n        S[index] += A[data[i++]] * data[i++] * (data[i++] === -1 ? 1 : A[data[i - 1]]);\r\n      }\r\n      A[index] = F[squash](S[index]);\r\n    }\r\n\r\n    var output = [];\r\n    for (i = A.length - data[1]; i < A.length; i++) output.push(A[i]);\r\n    return output;\r\n  },\r\n\r\n  /** Deserializes a dataset to an array of arrays */\r\n  deserializeDataSet: function (serializedSet) {\r\n    var set = [];\r\n\r\n    var sampleSize = serializedSet[0] + serializedSet[1];\r\n    for (var i = 0; i < (serializedSet.length - 2) / sampleSize; i++) {\r\n      let input = [];\r\n      for (var j = 2 + i * sampleSize; j < 2 + i * sampleSize + serializedSet[0]; j++) {\r\n        input.push(serializedSet[j]);\r\n      }\r\n      let output = [];\r\n      for (j = 2 + i * sampleSize + serializedSet[0]; j < 2 + i * sampleSize + sampleSize; j++) {\r\n        output.push(serializedSet[j]);\r\n      }\r\n      set.push(input);\r\n      set.push(output);\r\n    }\r\n\r\n    return set;\r\n  },\r\n\r\n  /** A list of compiled activation functions in a certain order */\r\n  activations: [\r\n    function (x) { return 1 / (1 + Math.exp(-x)); },\r\n    function (x) { return Math.tanh(x); },\r\n    function (x) { return x; },\r\n    function (x) { return x > 0 ? 1 : 0; },\r\n    function (x) { return x > 0 ? x : 0; },\r\n    function (x) { return x / (1 + Math.abs(x)); },\r\n    function (x) { return Math.sin(x); },\r\n    function (x) { return Math.exp(-Math.pow(x, 2)); },\r\n    function (x) { return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x; },\r\n    function (x) { return x > 0 ? 1 : -1; },\r\n    function (x) { return 2 / (1 + Math.exp(-x)) - 1; },\r\n    function (x) { return Math.max(-1, Math.min(1, x)); },\r\n    function (x) { return Math.abs(x); },\r\n    function (x) { return 1 - x; },\r\n    function (x) {\r\n      var a = 1.6732632423543772848170429916717;\r\n      return (x > 0 ? x : a * Math.exp(x) - a) * 1.0507009873554804934193349852946;\r\n    }\r\n  ]\r\n};\r\n\r\nmulti.testSerializedSet = function (set, cost, A, S, data, F) {\r\n  // Calculate how much samples are in the set\r\n  var error = 0;\r\n  for (var i = 0; i < set.length; i += 2) {\r\n    let output = multi.activateSerializedNetwork(set[i], A, S, data, F);\r\n    error += cost(set[i + 1], output);\r\n  }\r\n\r\n  return error / (set.length / 2);\r\n};\r\n\r\n/* Export */\r\nfor (var i in multi) {\r\n  module.exports[i] = multi[i];\r\n}\r\n", "/*******************************************************************************\r\n                                      CONFIG\r\n*******************************************************************************/\r\n\r\n// Config\r\nvar config = {\r\n  warnings: false\r\n};\r\n\r\n/* Export */\r\nmodule.exports = config;\r\n", "/* Export */\r\nmodule.exports = Neat;\r\n\r\n/* Import */\r\nvar Network = require('./architecture/network');\r\nvar methods = require('./methods/methods');\r\nvar config = require('./config');\r\n\r\n/* Easier variable naming */\r\nvar selection = methods.selection;\r\n\r\n/*******************************************************************************\r\n                                         NEAT\r\n*******************************************************************************/\r\n\r\nfunction Neat (input, output, fitness, options) {\r\n  this.input = input; // The input size of the networks\r\n  this.output = output; // The output size of the networks\r\n  this.fitness = fitness; // The fitness function to evaluate the networks\r\n\r\n  // Configure options\r\n  options = options || {};\r\n  this.equal = options.equal || false;\r\n  this.clear = options.clear || false;\r\n  this.popsize = options.popsize || 50;\r\n  this.elitism = options.elitism || 0;\r\n  this.provenance = options.provenance || 0;\r\n  this.mutationRate = options.mutationRate || 0.3;\r\n  this.mutationAmount = options.mutationAmount || 1;\r\n\r\n  this.fitnessPopulation = options.fitnessPopulation || false;\r\n\r\n  this.selection = options.selection || methods.selection.POWER;\r\n  this.crossover = options.crossover || [\r\n    methods.crossover.SINGLE_POINT,\r\n    methods.crossover.TWO_POINT,\r\n    methods.crossover.UNIFORM,\r\n    methods.crossover.AVERAGE\r\n  ];\r\n  this.mutation = options.mutation || methods.mutation.FFW;\r\n\r\n  this.template = options.network || false;\r\n\r\n  this.maxNodes = options.maxNodes || Infinity;\r\n  this.maxConns = options.maxConns || Infinity;\r\n  this.maxGates = options.maxGates || Infinity;\r\n\r\n  // Custom mutation selection function if given\r\n  this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;\r\n\r\n  // Generation counter\r\n  this.generation = 0;\r\n\r\n  // Initialise the genomes\r\n  this.createPool(this.template);\r\n}\r\n\r\nNeat.prototype = {\r\n  /**\r\n   * Create the initial pool of genomes\r\n   */\r\n  createPool: function (network) {\r\n    this.population = [];\r\n\r\n    for (var i = 0; i < this.popsize; i++) {\r\n      var copy;\r\n      if (this.template) {\r\n        copy = Network.fromJSON(network.toJSON());\r\n      } else {\r\n        copy = new Network(this.input, this.output);\r\n      }\r\n      copy.score = undefined;\r\n      this.population.push(copy);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evaluates, selects, breeds and mutates population\r\n   */\r\n  evolve: async function () {\r\n    // Check if evaluated, sort the population\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      await this.evaluate();\r\n    }\r\n    this.sort();\r\n\r\n    var fittest = Network.fromJSON(this.population[0].toJSON());\r\n    fittest.score = this.population[0].score;\r\n\r\n    var newPopulation = [];\r\n\r\n    // Elitism\r\n    var elitists = [];\r\n    for (var i = 0; i < this.elitism; i++) {\r\n      elitists.push(this.population[i]);\r\n    }\r\n\r\n    // Provenance\r\n    for (i = 0; i < this.provenance; i++) {\r\n      newPopulation.push(Network.fromJSON(this.template.toJSON()));\r\n    }\r\n\r\n    // Breed the next individuals\r\n    for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {\r\n      newPopulation.push(this.getOffspring());\r\n    }\r\n\r\n    // Replace the old population with the new population\r\n    this.population = newPopulation;\r\n    this.mutate();\r\n\r\n    this.population.push(...elitists);\r\n\r\n    // Reset the scores\r\n    for (i = 0; i < this.population.length; i++) {\r\n      this.population[i].score = undefined;\r\n    }\r\n\r\n    this.generation++;\r\n\r\n    return fittest;\r\n  },\r\n\r\n  /**\r\n   * Breeds two parents into an offspring, population MUST be surted\r\n   */\r\n  getOffspring: function () {\r\n    var parent1 = this.getParent();\r\n    var parent2 = this.getParent();\r\n\r\n    return Network.crossOver(parent1, parent2, this.equal);\r\n  },\r\n\r\n  /**\r\n   * Selects a random mutation method for a genome according to the parameters\r\n   */\r\n  selectMutationMethod: function (genome) {\r\n    var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];\r\n\r\n    if (mutationMethod === methods.mutation.ADD_NODE && genome.nodes.length >= this.maxNodes) {\r\n      if (config.warnings) console.warn('maxNodes exceeded!');\r\n      return;\r\n    }\r\n\r\n    if (mutationMethod === methods.mutation.ADD_CONN && genome.connections.length >= this.maxConns) {\r\n      if (config.warnings) console.warn('maxConns exceeded!');\r\n      return;\r\n    }\r\n\r\n    if (mutationMethod === methods.mutation.ADD_GATE && genome.gates.length >= this.maxGates) {\r\n      if (config.warnings) console.warn('maxGates exceeded!');\r\n      return;\r\n    }\r\n\r\n    return mutationMethod;\r\n  },\r\n\r\n  /**\r\n   * Mutates the given (or current) population\r\n   */\r\n  mutate: function () {\r\n    // Elitist genomes should not be included\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      if (Math.random() <= this.mutationRate) {\r\n        for (var j = 0; j < this.mutationAmount; j++) {\r\n          var mutationMethod = this.selectMutationMethod(this.population[i]);\r\n          this.population[i].mutate(mutationMethod);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evaluates the current population\r\n   */\r\n  evaluate: async function () {\r\n    var i;\r\n    if (this.fitnessPopulation) {\r\n      if (this.clear) {\r\n        for (i = 0; i < this.population.length; i++) {\r\n          this.population[i].clear();\r\n        }\r\n      }\r\n      await this.fitness(this.population);\r\n    } else {\r\n      for (i = 0; i < this.population.length; i++) {\r\n        var genome = this.population[i];\r\n        if (this.clear) genome.clear();\r\n        genome.score = await this.fitness(genome);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sorts the population by score\r\n   */\r\n  sort: function () {\r\n    this.population.sort(function (a, b) {\r\n      return b.score - a.score;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Returns the fittest genome of the current population\r\n   */\r\n  getFittest: function () {\r\n    // Check if evaluated\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      this.evaluate();\r\n    }\r\n    if (this.population[0].score < this.population[1].score) {\r\n      this.sort();\r\n    }\r\n\r\n    return this.population[0];\r\n  },\r\n\r\n  /**\r\n   * Returns the average fitness of the current population\r\n   */\r\n  getAverage: function () {\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      this.evaluate();\r\n    }\r\n\r\n    var score = 0;\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      score += this.population[i].score;\r\n    }\r\n\r\n    return score / this.population.length;\r\n  },\r\n\r\n  /**\r\n   * Gets a genome based on the selection function\r\n   * @return {Network} genome\r\n   */\r\n  getParent: function () {\r\n    var i;\r\n    switch (this.selection) {\r\n      case selection.POWER:\r\n        if (this.population[0].score < this.population[1].score) this.sort();\r\n\r\n        var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);\r\n        return this.population[index];\r\n      case selection.FITNESS_PROPORTIONATE:\r\n        // As negative fitnesses are possible\r\n        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values\r\n        // this is unnecessarily run for every individual, should be changed\r\n\r\n        var totalFitness = 0;\r\n        var minimalFitness = 0;\r\n        for (i = 0; i < this.population.length; i++) {\r\n          var score = this.population[i].score;\r\n          minimalFitness = score < minimalFitness ? score : minimalFitness;\r\n          totalFitness += score;\r\n        }\r\n\r\n        minimalFitness = Math.abs(minimalFitness);\r\n        totalFitness += minimalFitness * this.population.length;\r\n\r\n        var random = Math.random() * totalFitness;\r\n        var value = 0;\r\n\r\n        for (i = 0; i < this.population.length; i++) {\r\n          let genome = this.population[i];\r\n          value += genome.score + minimalFitness;\r\n          if (random < value) return genome;\r\n        }\r\n\r\n        // if all scores equal, return random genome\r\n        return this.population[Math.floor(Math.random() * this.population.length)];\r\n      case selection.TOURNAMENT:\r\n        if (this.selection.size > this.popsize) {\r\n          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');\r\n        }\r\n\r\n        // Create a tournament\r\n        var individuals = [];\r\n        for (i = 0; i < this.selection.size; i++) {\r\n          let random = this.population[Math.floor(Math.random() * this.population.length)];\r\n          individuals.push(random);\r\n        }\r\n\r\n        // Sort the tournament individuals by score\r\n        individuals.sort(function (a, b) {\r\n          return b.score - a.score;\r\n        });\r\n\r\n        // Select an individual\r\n        for (i = 0; i < this.selection.size; i++) {\r\n          if (Math.random() < this.selection.probability || i === this.selection.size - 1) {\r\n            return individuals[i];\r\n          }\r\n        }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Export the current population to a json object\r\n   */\r\n  export: function () {\r\n    var json = [];\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      var genome = this.population[i];\r\n      json.push(genome.toJSON());\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Import population from a json object\r\n   */\r\n  import: function (json) {\r\n    var population = [];\r\n    for (var i = 0; i < json.length; i++) {\r\n      var genome = json[i];\r\n      population.push(Network.fromJSON(genome));\r\n    }\r\n    this.population = population;\r\n    this.popsize = population.length;\r\n  }\r\n};\r\n", "/* Export */\r\nmodule.exports = Node;\r\n\r\n/* Import */\r\nvar methods = require('../methods/methods');\r\nvar Connection = require('./connection');\r\nvar config = require('../config');\r\n\r\n/*******************************************************************************\r\n                                         NODE\r\n*******************************************************************************/\r\n\r\nfunction Node (type) {\r\n  this.bias = (type === 'input') ? 0 : Math.random() * 0.2 - 0.1;\r\n  this.squash = methods.activation.LOGISTIC;\r\n  this.type = type || 'hidden';\r\n\r\n  this.activation = 0;\r\n  this.state = 0;\r\n  this.old = 0;\r\n\r\n  // For dropout\r\n  this.mask = 1;\r\n\r\n  // For tracking momentum\r\n  this.previousDeltaBias = 0;\r\n\r\n  // Batch training\r\n  this.totalDeltaBias = 0;\r\n\r\n  this.connections = {\r\n    in: [],\r\n    out: [],\r\n    gated: [],\r\n    self: new Connection(this, this, 0)\r\n  };\r\n\r\n  // Data for backpropagation\r\n  this.error = {\r\n    responsibility: 0,\r\n    projected: 0,\r\n    gated: 0\r\n  };\r\n}\r\n\r\nNode.prototype = {\r\n  /**\r\n   * Activates the node\r\n   */\r\n  activate: function (input) {\r\n    // Check if an input is given\r\n    if (typeof input !== 'undefined') {\r\n      this.activation = input;\r\n      return this.activation;\r\n    }\r\n\r\n    this.old = this.state;\r\n\r\n    // All activation sources coming from the node itself\r\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\r\n\r\n    // Activation sources coming from connections\r\n    var i;\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n      this.state += connection.from.activation * connection.weight * connection.gain;\r\n    }\r\n\r\n    // Squash the values received\r\n    this.activation = this.squash(this.state) * this.mask;\r\n    this.derivative = this.squash(this.state, true);\r\n\r\n    // Update traces\r\n    var nodes = [];\r\n    var influences = [];\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      let conn = this.connections.gated[i];\r\n      let node = conn.to;\r\n\r\n      let index = nodes.indexOf(node);\r\n      if (index > -1) {\r\n        influences[index] += conn.weight * conn.from.activation;\r\n      } else {\r\n        nodes.push(node);\r\n        influences.push(conn.weight * conn.from.activation +\r\n          (node.connections.self.gater === this ? node.old : 0));\r\n      }\r\n\r\n      // Adjust the gain to this nodes' activation\r\n      conn.gain = this.activation;\r\n    }\r\n\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      let connection = this.connections.in[i];\r\n\r\n      // Elegibility trace\r\n      connection.elegibility = this.connections.self.gain * this.connections.self.weight *\r\n        connection.elegibility + connection.from.activation * connection.gain;\r\n\r\n      // Extended trace\r\n      for (var j = 0; j < nodes.length; j++) {\r\n        let node = nodes[j];\r\n        let influence = influences[j];\r\n\r\n        let index = connection.xtrace.nodes.indexOf(node);\r\n\r\n        if (index > -1) {\r\n          connection.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight *\r\n            connection.xtrace.values[index] + this.derivative * connection.elegibility * influence;\r\n        } else {\r\n          // Does not exist there yet, might be through mutation\r\n          connection.xtrace.nodes.push(node);\r\n          connection.xtrace.values.push(this.derivative * connection.elegibility * influence);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.activation;\r\n  },\r\n\r\n  /**\r\n   * Activates the node without calculating elegibility traces and such\r\n   */\r\n  noTraceActivate: function (input) {\r\n    // Check if an input is given\r\n    if (typeof input !== 'undefined') {\r\n      this.activation = input;\r\n      return this.activation;\r\n    }\r\n\r\n    // All activation sources coming from the node itself\r\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\r\n\r\n    // Activation sources coming from connections\r\n    var i;\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n      this.state += connection.from.activation * connection.weight * connection.gain;\r\n    }\r\n\r\n    // Squash the values received\r\n    this.activation = this.squash(this.state);\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      this.connections.gated[i].gain = this.activation;\r\n    }\r\n\r\n    return this.activation;\r\n  },\r\n\r\n  /**\r\n   * Back-propagate the error, aka learn\r\n   */\r\n  propagate: function (rate, momentum, update, target) {\r\n    momentum = momentum || 0;\r\n    rate = rate || 0.3;\r\n\r\n    // Error accumulator\r\n    var error = 0;\r\n\r\n    // Output nodes get their error from the enviroment\r\n    if (this.type === 'output') {\r\n      this.error.responsibility = this.error.projected = target - this.activation;\r\n    } else { // the rest of the nodes compute their error responsibilities by backpropagation\r\n      // error responsibilities from all the connections projected from this node\r\n      var i;\r\n      for (i = 0; i < this.connections.out.length; i++) {\r\n        let connection = this.connections.out[i];\r\n        let node = connection.to;\r\n        // Eq. 21\r\n        error += node.error.responsibility * connection.weight * connection.gain;\r\n      }\r\n\r\n      // Projected error responsibility\r\n      this.error.projected = this.derivative * error;\r\n\r\n      // Error responsibilities from all connections gated by this neuron\r\n      error = 0;\r\n\r\n      for (i = 0; i < this.connections.gated.length; i++) {\r\n        let conn = this.connections.gated[i];\r\n        let node = conn.to;\r\n        let influence = node.connections.self.gater === this ? node.old : 0;\r\n\r\n        influence += conn.weight * conn.from.activation;\r\n        error += node.error.responsibility * influence;\r\n      }\r\n\r\n      // Gated error responsibility\r\n      this.error.gated = this.derivative * error;\r\n\r\n      // Error responsibility\r\n      this.error.responsibility = this.error.projected + this.error.gated;\r\n    }\r\n\r\n    if (this.type === 'constant') return;\r\n\r\n    // Adjust all the node's incoming connections\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      let connection = this.connections.in[i];\r\n\r\n      let gradient = this.error.projected * connection.elegibility;\r\n\r\n      for (var j = 0; j < connection.xtrace.nodes.length; j++) {\r\n        let node = connection.xtrace.nodes[j];\r\n        let value = connection.xtrace.values[j];\r\n        gradient += node.error.responsibility * value;\r\n      }\r\n\r\n      // Adjust weight\r\n      let deltaWeight = rate * gradient * this.mask;\r\n      connection.totalDeltaWeight += deltaWeight;\r\n      if (update) {\r\n        connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;\r\n        connection.weight += connection.totalDeltaWeight;\r\n        connection.previousDeltaWeight = connection.totalDeltaWeight;\r\n        connection.totalDeltaWeight = 0;\r\n      }\r\n    }\r\n\r\n    // Adjust bias\r\n    var deltaBias = rate * this.error.responsibility;\r\n    this.totalDeltaBias += deltaBias;\r\n    if (update) {\r\n      this.totalDeltaBias += momentum * this.previousDeltaBias;\r\n      this.bias += this.totalDeltaBias;\r\n      this.previousDeltaBias = this.totalDeltaBias;\r\n      this.totalDeltaBias = 0;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Creates a connection from this node to the given node\r\n   */\r\n  connect: function (target, weight) {\r\n    var connections = [];\r\n    if (typeof target.bias !== 'undefined') { // must be a node!\r\n      if (target === this) {\r\n        // Turn on the self connection by setting the weight\r\n        if (this.connections.self.weight !== 0) {\r\n          if (config.warnings) console.warn('This connection already exists!');\r\n        } else {\r\n          this.connections.self.weight = weight || 1;\r\n        }\r\n        connections.push(this.connections.self);\r\n      } else if (this.isProjectingTo(target)) {\r\n        throw new Error('Already projecting a connection to this node!');\r\n      } else {\r\n        let connection = new Connection(this, target, weight);\r\n        target.connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n\r\n        connections.push(connection);\r\n      }\r\n    } else { // should be a group\r\n      for (var i = 0; i < target.nodes.length; i++) {\r\n        let connection = new Connection(this, target.nodes[i], weight);\r\n        target.nodes[i].connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n        target.connections.in.push(connection);\r\n\r\n        connections.push(connection);\r\n      }\r\n    }\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Disconnects this node from the other node\r\n   */\r\n  disconnect: function (node, twosided) {\r\n    if (this === node) {\r\n      this.connections.self.weight = 0;\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < this.connections.out.length; i++) {\r\n      let conn = this.connections.out[i];\r\n      if (conn.to === node) {\r\n        this.connections.out.splice(i, 1);\r\n        let j = conn.to.connections.in.indexOf(conn);\r\n        conn.to.connections.in.splice(j, 1);\r\n        if (conn.gater !== null) conn.gater.ungate(conn);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (twosided) {\r\n      node.disconnect(this);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Make this node gate a connection\r\n   */\r\n  gate: function (connections) {\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n\r\n      this.connections.gated.push(connection);\r\n      connection.gater = this;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Removes the gates from this node from the given connection(s)\r\n   */\r\n  ungate: function (connections) {\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (var i = connections.length - 1; i >= 0; i--) {\r\n      var connection = connections[i];\r\n\r\n      var index = this.connections.gated.indexOf(connection);\r\n      this.connections.gated.splice(index, 1);\r\n      connection.gater = null;\r\n      connection.gain = 1;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of the node\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n\r\n      connection.elegibility = 0;\r\n      connection.xtrace = {\r\n        nodes: [],\r\n        values: []\r\n      };\r\n    }\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      let conn = this.connections.gated[i];\r\n      conn.gain = 0;\r\n    }\r\n\r\n    this.error.responsibility = this.error.projected = this.error.gated = 0;\r\n    this.old = this.state = this.activation = 0;\r\n  },\r\n\r\n  /**\r\n   * Mutates the node with the given method\r\n   */\r\n  mutate: function (method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('No mutate method given!');\r\n    } else if (!(method.name in methods.mutation)) {\r\n      throw new Error('This method does not exist!');\r\n    }\r\n\r\n    switch (method) {\r\n      case methods.mutation.MOD_ACTIVATION:\r\n        // Can't be the same squash\r\n        var squash = method.allowed[(method.allowed.indexOf(this.squash) + Math.floor(Math.random() * (method.allowed.length - 1)) + 1) % method.allowed.length];\r\n        this.squash = squash;\r\n        break;\r\n      case methods.mutation.MOD_BIAS:\r\n        var modification = Math.random() * (method.max - method.min) + method.min;\r\n        this.bias += modification;\r\n        break;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Checks if this node is projecting to the given node\r\n   */\r\n  isProjectingTo: function (node) {\r\n    if (node === this && this.connections.self.weight !== 0) return true;\r\n\r\n    for (var i = 0; i < this.connections.out.length; i++) {\r\n      var conn = this.connections.out[i];\r\n      if (conn.to === node) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Checks if the given node is projecting to this node\r\n   */\r\n  isProjectedBy: function (node) {\r\n    if (node === this && this.connections.self.weight !== 0) return true;\r\n\r\n    for (var i = 0; i < this.connections.in.length; i++) {\r\n      var conn = this.connections.in[i];\r\n      if (conn.from === node) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Converts the node to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      bias: this.bias,\r\n      type: this.type,\r\n      squash: this.squash.name,\r\n      mask: this.mask\r\n    };\r\n\r\n    return json;\r\n  }\r\n};\r\n\r\n/**\r\n * Convert a json object to a node\r\n */\r\nNode.fromJSON = function (json) {\r\n  var node = new Node();\r\n  node.bias = json.bias;\r\n  node.type = json.type;\r\n  node.mask = json.mask;\r\n  node.squash = methods.activation[json.squash];\r\n\r\n  return node;\r\n};\r\n", "export default new Proxy({}, {\n  get() {\n    throw new Error('Module \"os\" has been externalized for browser compatibility and cannot be accessed in client code.')\n  }\n})", "/* Export */\r\nmodule.exports = Network;\r\n\r\n/* Import */\r\nvar multi = require('../multithreading/multi');\r\nvar methods = require('../methods/methods');\r\nvar Connection = require('./connection');\r\nvar config = require('../config');\r\nvar Neat = require('../neat');\r\nvar Node = require('./node');\r\n\r\n/* Easier variable naming */\r\nvar mutation = methods.mutation;\r\n\r\n/*******************************************************************************\r\n                                 NETWORK\r\n*******************************************************************************/\r\n\r\nfunction Network (input, output) {\r\n  if (typeof input === 'undefined' || typeof output === 'undefined') {\r\n    throw new Error('No input or output size given');\r\n  }\r\n\r\n  this.input = input;\r\n  this.output = output;\r\n\r\n  // Store all the node and connection genes\r\n  this.nodes = []; // Stored in activation order\r\n  this.connections = [];\r\n  this.gates = [];\r\n  this.selfconns = [];\r\n\r\n  // Regularization\r\n  this.dropout = 0;\r\n\r\n  // Create input and output nodes\r\n  var i;\r\n  for (i = 0; i < this.input + this.output; i++) {\r\n    var type = i < this.input ? 'input' : 'output';\r\n    this.nodes.push(new Node(type));\r\n  }\r\n\r\n  // Connect input nodes with output nodes directly\r\n  for (i = 0; i < this.input; i++) {\r\n    for (var j = this.input; j < this.output + this.input; j++) {\r\n      // https://stats.stackexchange.com/a/248040/147931\r\n      var weight = Math.random() * this.input * Math.sqrt(2 / this.input);\r\n      this.connect(this.nodes[i], this.nodes[j], weight);\r\n    }\r\n  }\r\n}\r\n\r\nNetwork.prototype = {\r\n  /**\r\n   * Activates the network\r\n   */\r\n  activate: function (input, training) {\r\n    var output = [];\r\n\r\n    // Activate nodes chronologically\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (this.nodes[i].type === 'input') {\r\n        this.nodes[i].activate(input[i]);\r\n      } else if (this.nodes[i].type === 'output') {\r\n        var activation = this.nodes[i].activate();\r\n        output.push(activation);\r\n      } else {\r\n        if (training) this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;\r\n        this.nodes[i].activate();\r\n      }\r\n    }\r\n\r\n    return output;\r\n  },\r\n\r\n  /**\r\n   * Activates the network without calculating elegibility traces and such\r\n   */\r\n  noTraceActivate: function (input) {\r\n    var output = [];\r\n\r\n    // Activate nodes chronologically\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (this.nodes[i].type === 'input') {\r\n        this.nodes[i].noTraceActivate(input[i]);\r\n      } else if (this.nodes[i].type === 'output') {\r\n        var activation = this.nodes[i].noTraceActivate();\r\n        output.push(activation);\r\n      } else {\r\n        this.nodes[i].noTraceActivate();\r\n      }\r\n    }\r\n\r\n    return output;\r\n  },\r\n\r\n  /**\r\n   * Backpropagate the network\r\n   */\r\n  propagate: function (rate, momentum, update, target) {\r\n    if (typeof target === 'undefined' || target.length !== this.output) {\r\n      throw new Error('Output target length should match network output length');\r\n    }\r\n\r\n    var targetIndex = target.length;\r\n\r\n    // Propagate output nodes\r\n    var i;\r\n    for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {\r\n      this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);\r\n    }\r\n\r\n    // Propagate hidden and input nodes\r\n    for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {\r\n      this.nodes[i].propagate(rate, momentum, update);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of the network\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the from node to the to node\r\n   */\r\n  connect: function (from, to, weight) {\r\n    var connections = from.connect(to, weight);\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (from !== to) {\r\n        this.connections.push(connection);\r\n      } else {\r\n        this.selfconns.push(connection);\r\n      }\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Disconnects the from node from the to node\r\n   */\r\n  disconnect: function (from, to) {\r\n    // Delete the connection in the network's connection array\r\n    var connections = from === to ? this.selfconns : this.connections;\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (connection.from === from && connection.to === to) {\r\n        if (connection.gater !== null) this.ungate(connection);\r\n        connections.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Delete the connection at the sending and receiving neuron\r\n    from.disconnect(to);\r\n  },\r\n\r\n  /**\r\n   * Gate a connection with a node\r\n   */\r\n  gate: function (node, connection) {\r\n    if (this.nodes.indexOf(node) === -1) {\r\n      throw new Error('This node is not part of the network!');\r\n    } else if (connection.gater != null) {\r\n      if (config.warnings) console.warn('This connection is already gated!');\r\n      return;\r\n    }\r\n    node.gate(connection);\r\n    this.gates.push(connection);\r\n  },\r\n\r\n  /**\r\n   *  Remove the gate of a connection\r\n   */\r\n  ungate: function (connection) {\r\n    var index = this.gates.indexOf(connection);\r\n    if (index === -1) {\r\n      throw new Error('This connection is not gated!');\r\n    }\r\n\r\n    this.gates.splice(index, 1);\r\n    connection.gater.ungate(connection);\r\n  },\r\n\r\n  /**\r\n   *  Removes a node from the network\r\n   */\r\n  remove: function (node) {\r\n    var index = this.nodes.indexOf(node);\r\n\r\n    if (index === -1) {\r\n      throw new Error('This node does not exist in the network!');\r\n    }\r\n\r\n    // Keep track of gaters\r\n    var gaters = [];\r\n\r\n    // Remove selfconnections from this.selfconns\r\n    this.disconnect(node, node);\r\n\r\n    // Get all its inputting nodes\r\n    var inputs = [];\r\n    for (var i = node.connections.in.length - 1; i >= 0; i--) {\r\n      let connection = node.connections.in[i];\r\n      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {\r\n        gaters.push(connection.gater);\r\n      }\r\n      inputs.push(connection.from);\r\n      this.disconnect(connection.from, node);\r\n    }\r\n\r\n    // Get all its outputing nodes\r\n    var outputs = [];\r\n    for (i = node.connections.out.length - 1; i >= 0; i--) {\r\n      let connection = node.connections.out[i];\r\n      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {\r\n        gaters.push(connection.gater);\r\n      }\r\n      outputs.push(connection.to);\r\n      this.disconnect(node, connection.to);\r\n    }\r\n\r\n    // Connect the input nodes to the output nodes (if not already connected)\r\n    var connections = [];\r\n    for (i = 0; i < inputs.length; i++) {\r\n      let input = inputs[i];\r\n      for (var j = 0; j < outputs.length; j++) {\r\n        let output = outputs[j];\r\n        if (!input.isProjectingTo(output)) {\r\n          var conn = this.connect(input, output);\r\n          connections.push(conn[0]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Gate random connections with gaters\r\n    for (i = 0; i < gaters.length; i++) {\r\n      if (connections.length === 0) break;\r\n\r\n      let gater = gaters[i];\r\n      let connIndex = Math.floor(Math.random() * connections.length);\r\n\r\n      this.gate(gater, connections[connIndex]);\r\n      connections.splice(connIndex, 1);\r\n    }\r\n\r\n    // Remove gated connections gated by this node\r\n    for (i = node.connections.gated.length - 1; i >= 0; i--) {\r\n      let conn = node.connections.gated[i];\r\n      this.ungate(conn);\r\n    }\r\n\r\n    // Remove selfconnection\r\n    this.disconnect(node, node);\r\n\r\n    // Remove the node from this.nodes\r\n    this.nodes.splice(index, 1);\r\n  },\r\n\r\n  /**\r\n   * Mutates the network with the given method\r\n   */\r\n  mutate: function (method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('No (correct) mutate method given!');\r\n    }\r\n\r\n    var i, j;\r\n    switch (method) {\r\n      case mutation.ADD_NODE:\r\n        // Look for an existing connection and place a node in between\r\n        var connection = this.connections[Math.floor(Math.random() * this.connections.length)];\r\n        var gater = connection.gater;\r\n        this.disconnect(connection.from, connection.to);\r\n\r\n        // Insert the new node right before the old connection.to\r\n        var toIndex = this.nodes.indexOf(connection.to);\r\n        var node = new Node('hidden');\r\n\r\n        // Random squash function\r\n        node.mutate(mutation.MOD_ACTIVATION);\r\n\r\n        // Place it in this.nodes\r\n        var minBound = Math.min(toIndex, this.nodes.length - this.output);\r\n        this.nodes.splice(minBound, 0, node);\r\n\r\n        // Now create two new connections\r\n        var newConn1 = this.connect(connection.from, node)[0];\r\n        var newConn2 = this.connect(node, connection.to)[0];\r\n\r\n        // Check if the original connection was gated\r\n        if (gater != null) {\r\n          this.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);\r\n        }\r\n        break;\r\n      case mutation.SUB_NODE:\r\n        // Check if there are nodes left to remove\r\n        if (this.nodes.length === this.input + this.output) {\r\n          if (config.warnings) console.warn('No more nodes left to remove!');\r\n          break;\r\n        }\r\n\r\n        // Select a node which isn't an input or output node\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.output - this.input) + this.input);\r\n        this.remove(this.nodes[index]);\r\n        break;\r\n      case mutation.ADD_CONN:\r\n        // Create an array of all uncreated (feedforward) connections\r\n        var available = [];\r\n        for (i = 0; i < this.nodes.length - this.output; i++) {\r\n          let node1 = this.nodes[i];\r\n          for (j = Math.max(i + 1, this.input); j < this.nodes.length; j++) {\r\n            let node2 = this.nodes[j];\r\n            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);\r\n          }\r\n        }\r\n\r\n        if (available.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to be made!');\r\n          break;\r\n        }\r\n\r\n        var pair = available[Math.floor(Math.random() * available.length)];\r\n        this.connect(pair[0], pair[1]);\r\n        break;\r\n      case mutation.SUB_CONN:\r\n        // List of possible connections that can be removed\r\n        var possible = [];\r\n\r\n        for (i = 0; i < this.connections.length; i++) {\r\n          let conn = this.connections[i];\r\n          // Check if it is not disabling a node\r\n          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.to) > this.nodes.indexOf(conn.from)) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No connections to remove!');\r\n          break;\r\n        }\r\n\r\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\r\n        this.disconnect(randomConn.from, randomConn.to);\r\n        break;\r\n      case mutation.MOD_WEIGHT:\r\n        var allconnections = this.connections.concat(this.selfconns);\r\n\r\n        var connection = allconnections[Math.floor(Math.random() * allconnections.length)];\r\n        var modification = Math.random() * (method.max - method.min) + method.min;\r\n        connection.weight += modification;\r\n        break;\r\n      case mutation.MOD_BIAS:\r\n        // Has no effect on input node, so they are excluded\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n        node.mutate(method);\r\n        break;\r\n      case mutation.MOD_ACTIVATION:\r\n        // Has no effect on input node, so they are excluded\r\n        if (!method.mutateOutput && this.input + this.output === this.nodes.length) {\r\n          if (config.warnings) console.warn('No nodes that allow mutation of activation function');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n\r\n        node.mutate(method);\r\n        break;\r\n      case mutation.ADD_SELF_CONN:\r\n        // Check which nodes aren't selfconnected yet\r\n        var possible = [];\r\n        for (i = this.input; i < this.nodes.length; i++) {\r\n          let node = this.nodes[i];\r\n          if (node.connections.self.weight === 0) {\r\n            possible.push(node);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No more self-connections to add!');\r\n          break;\r\n        }\r\n\r\n        // Select a random node\r\n        var node = possible[Math.floor(Math.random() * possible.length)];\r\n\r\n        // Connect it to himself\r\n        this.connect(node, node);\r\n        break;\r\n      case mutation.SUB_SELF_CONN:\r\n        if (this.selfconns.length === 0) {\r\n          if (config.warnings) console.warn('No more self-connections to remove!');\r\n          break;\r\n        }\r\n        var conn = this.selfconns[Math.floor(Math.random() * this.selfconns.length)];\r\n        this.disconnect(conn.from, conn.to);\r\n        break;\r\n      case mutation.ADD_GATE:\r\n        var allconnections = this.connections.concat(this.selfconns);\r\n\r\n        // Create a list of all non-gated connections\r\n        var possible = [];\r\n        for (i = 0; i < allconnections.length; i++) {\r\n          let conn = allconnections[i];\r\n          if (conn.gater === null) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to gate!');\r\n          break;\r\n        }\r\n\r\n        // Select a random gater node and connection, can't be gated by input\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n        var conn = possible[Math.floor(Math.random() * possible.length)];\r\n\r\n        // Gate the connection with the node\r\n        this.gate(node, conn);\r\n        break;\r\n      case mutation.SUB_GATE:\r\n        // Select a random gated connection\r\n        if (this.gates.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to ungate!');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * this.gates.length);\r\n        var gatedconn = this.gates[index];\r\n\r\n        this.ungate(gatedconn);\r\n        break;\r\n      case mutation.ADD_BACK_CONN:\r\n        // Create an array of all uncreated (backfed) connections\r\n        var available = [];\r\n        for (i = this.input; i < this.nodes.length; i++) {\r\n          let node1 = this.nodes[i];\r\n          for (j = this.input; j < i; j++) {\r\n            let node2 = this.nodes[j];\r\n            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);\r\n          }\r\n        }\r\n\r\n        if (available.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to be made!');\r\n          break;\r\n        }\r\n\r\n        var pair = available[Math.floor(Math.random() * available.length)];\r\n        this.connect(pair[0], pair[1]);\r\n        break;\r\n      case mutation.SUB_BACK_CONN:\r\n        // List of possible connections that can be removed\r\n        var possible = [];\r\n\r\n        for (i = 0; i < this.connections.length; i++) {\r\n          let conn = this.connections[i];\r\n          // Check if it is not disabling a node\r\n          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.from) > this.nodes.indexOf(conn.to)) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No connections to remove!');\r\n          break;\r\n        }\r\n\r\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\r\n        this.disconnect(randomConn.from, randomConn.to);\r\n        break;\r\n      case mutation.SWAP_NODES:\r\n        // Has no effect on input node, so they are excluded\r\n        if ((method.mutateOutput && this.nodes.length - this.input < 2) ||\r\n          (!method.mutateOutput && this.nodes.length - this.input - this.output < 2)) {\r\n          if (config.warnings) console.warn('No nodes that allow swapping of bias and activation function');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node1 = this.nodes[index];\r\n        index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node2 = this.nodes[index];\r\n\r\n        var biasTemp = node1.bias;\r\n        var squashTemp = node1.squash;\r\n\r\n        node1.bias = node2.bias;\r\n        node1.squash = node2.squash;\r\n        node2.bias = biasTemp;\r\n        node2.squash = squashTemp;\r\n        break;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Train the given set to this network\r\n   */\r\n  train: function (set, options) {\r\n    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\r\n      throw new Error('Dataset input/output size should be same as network input/output size!');\r\n    }\r\n\r\n    options = options || {};\r\n\r\n    // Warning messages\r\n    if (typeof options.rate === 'undefined') {\r\n      if (config.warnings) console.warn('Using default learning rate, please define a rate!');\r\n    }\r\n    if (typeof options.iterations === 'undefined') {\r\n      if (config.warnings) console.warn('No target iterations given, running until error is reached!');\r\n    }\r\n\r\n    // Read the options\r\n    var targetError = options.error || 0.05;\r\n    var cost = options.cost || methods.cost.MSE;\r\n    var baseRate = options.rate || 0.3;\r\n    var dropout = options.dropout || 0;\r\n    var momentum = options.momentum || 0;\r\n    var batchSize = options.batchSize || 1; // online learning\r\n    var ratePolicy = options.ratePolicy || methods.rate.FIXED();\r\n\r\n    var start = Date.now();\r\n\r\n    if (batchSize > set.length) {\r\n      throw new Error('Batch size must be smaller or equal to dataset length!');\r\n    } else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\r\n      throw new Error('At least one of the following options must be specified: error, iterations');\r\n    } else if (typeof options.error === 'undefined') {\r\n      targetError = -1; // run until iterations\r\n    } else if (typeof options.iterations === 'undefined') {\r\n      options.iterations = 0; // run until target error\r\n    }\r\n\r\n    // Save to network\r\n    this.dropout = dropout;\r\n\r\n    if (options.crossValidate) {\r\n      let numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);\r\n      var trainSet = set.slice(0, numTrain);\r\n      var testSet = set.slice(numTrain);\r\n    }\r\n\r\n    // Loops the training process\r\n    var currentRate = baseRate;\r\n    var iteration = 0;\r\n    var error = 1;\r\n\r\n    var i, j, x;\r\n    while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {\r\n      if (options.crossValidate && error <= options.crossValidate.testError) break;\r\n\r\n      iteration++;\r\n\r\n      // Update the rate\r\n      currentRate = ratePolicy(baseRate, iteration);\r\n\r\n      // Checks if cross validation is enabled\r\n      if (options.crossValidate) {\r\n        this._trainSet(trainSet, batchSize, currentRate, momentum, cost);\r\n        if (options.clear) this.clear();\r\n        error = this.test(testSet, cost).error;\r\n        if (options.clear) this.clear();\r\n      } else {\r\n        error = this._trainSet(set, batchSize, currentRate, momentum, cost);\r\n        if (options.clear) this.clear();\r\n      }\r\n\r\n      // Checks for options such as scheduled logs and shuffling\r\n      if (options.shuffle) {\r\n        for (j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x);\r\n      }\r\n\r\n      if (options.log && iteration % options.log === 0) {\r\n        console.log('iteration', iteration, 'error', error, 'rate', currentRate);\r\n      }\r\n\r\n      if (options.schedule && iteration % options.schedule.iterations === 0) {\r\n        options.schedule.function({ error: error, iteration: iteration });\r\n      }\r\n    }\r\n\r\n    if (options.clear) this.clear();\r\n\r\n    if (dropout) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\r\n          this.nodes[i].mask = 1 - this.dropout;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      error: error,\r\n      iterations: iteration,\r\n      time: Date.now() - start\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Performs one training epoch and returns the error\r\n   * private function used in this.train\r\n   */\r\n  _trainSet: function (set, batchSize, currentRate, momentum, costFunction) {\r\n    var errorSum = 0;\r\n    for (var i = 0; i < set.length; i++) {\r\n      var input = set[i].input;\r\n      var target = set[i].output;\r\n\r\n      var update = !!((i + 1) % batchSize === 0 || (i + 1) === set.length);\r\n\r\n      var output = this.activate(input, true);\r\n      this.propagate(currentRate, momentum, update, target);\r\n\r\n      errorSum += costFunction(target, output);\r\n    }\r\n    return errorSum / set.length;\r\n  },\r\n\r\n  /**\r\n   * Tests a set and returns the error and elapsed time\r\n   */\r\n  test: function (set, cost = methods.cost.MSE) {\r\n    // Check if dropout is enabled, set correct mask\r\n    var i;\r\n    if (this.dropout) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\r\n          this.nodes[i].mask = 1 - this.dropout;\r\n        }\r\n      }\r\n    }\r\n\r\n    var error = 0;\r\n    var start = Date.now();\r\n\r\n    for (i = 0; i < set.length; i++) {\r\n      let input = set[i].input;\r\n      let target = set[i].output;\r\n      let output = this.noTraceActivate(input);\r\n      error += cost(target, output);\r\n    }\r\n\r\n    error /= set.length;\r\n\r\n    var results = {\r\n      error: error,\r\n      time: Date.now() - start\r\n    };\r\n\r\n    return results;\r\n  },\r\n\r\n  /**\r\n   * Creates a json that can be used to create a graph with d3 and webcola\r\n   */\r\n  graph: function (width, height) {\r\n    var input = 0;\r\n    var output = 0;\r\n\r\n    var json = {\r\n      nodes: [],\r\n      links: [],\r\n      constraints: [{\r\n        type: 'alignment',\r\n        axis: 'x',\r\n        offsets: []\r\n      }, {\r\n        type: 'alignment',\r\n        axis: 'y',\r\n        offsets: []\r\n      }]\r\n    };\r\n\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      var node = this.nodes[i];\r\n\r\n      if (node.type === 'input') {\r\n        if (this.input === 1) {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0\r\n          });\r\n        } else {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0.8 * width / (this.input - 1) * input++\r\n          });\r\n        }\r\n        json.constraints[1].offsets.push({\r\n          node: i,\r\n          offset: 0\r\n        });\r\n      } else if (node.type === 'output') {\r\n        if (this.output === 1) {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0\r\n          });\r\n        } else {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0.8 * width / (this.output - 1) * output++\r\n          });\r\n        }\r\n        json.constraints[1].offsets.push({\r\n          node: i,\r\n          offset: -0.8 * height\r\n        });\r\n      }\r\n\r\n      json.nodes.push({\r\n        id: i,\r\n        name: node.type === 'hidden' ? node.squash.name : node.type.toUpperCase(),\r\n        activation: node.activation,\r\n        bias: node.bias\r\n      });\r\n    }\r\n\r\n    var connections = this.connections.concat(this.selfconns);\r\n    for (i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (connection.gater == null) {\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.from),\r\n          target: this.nodes.indexOf(connection.to),\r\n          weight: connection.weight\r\n        });\r\n      } else {\r\n        // Add a gater 'node'\r\n        var index = json.nodes.length;\r\n        json.nodes.push({\r\n          id: index,\r\n          activation: connection.gater.activation,\r\n          name: 'GATE'\r\n        });\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.from),\r\n          target: index,\r\n          weight: 1 / 2 * connection.weight\r\n        });\r\n        json.links.push({\r\n          source: index,\r\n          target: this.nodes.indexOf(connection.to),\r\n          weight: 1 / 2 * connection.weight\r\n        });\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.gater),\r\n          target: index,\r\n          weight: connection.gater.activation,\r\n          gate: true\r\n        });\r\n      }\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Convert the network to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      nodes: [],\r\n      connections: [],\r\n      input: this.input,\r\n      output: this.output,\r\n      dropout: this.dropout\r\n    };\r\n\r\n    // So we don't have to use expensive .indexOf()\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].index = i;\r\n    }\r\n\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      let tojson = node.toJSON();\r\n      tojson.index = i;\r\n      json.nodes.push(tojson);\r\n\r\n      if (node.connections.self.weight !== 0) {\r\n        let tojson = node.connections.self.toJSON();\r\n        tojson.from = i;\r\n        tojson.to = i;\r\n\r\n        tojson.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;\r\n        json.connections.push(tojson);\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < this.connections.length; i++) {\r\n      let conn = this.connections[i];\r\n      let tojson = conn.toJSON();\r\n      tojson.from = conn.from.index;\r\n      tojson.to = conn.to.index;\r\n\r\n      tojson.gater = conn.gater != null ? conn.gater.index : null;\r\n\r\n      json.connections.push(tojson);\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node in this network\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].bias = values.bias || this.nodes[i].bias;\r\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evolves the network to reach a lower error on a dataset\r\n   */\r\n  evolve: async function (set, options) {\r\n    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\r\n      throw new Error('Dataset input/output size should be same as network input/output size!');\r\n    }\r\n\r\n    // Read the options\r\n    options = options || {};\r\n    var targetError = typeof options.error !== 'undefined' ? options.error : 0.05;\r\n    var growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;\r\n    var cost = options.cost || methods.cost.MSE;\r\n    var amount = options.amount || 1;\r\n\r\n    var threads = options.threads;\r\n    if (typeof threads === 'undefined') {\r\n      if (typeof window === 'undefined') { // Node.js\r\n        threads = require('os').cpus().length;\r\n      } else { // Browser\r\n        threads = navigator.hardwareConcurrency;\r\n      }\r\n    }\r\n\r\n    var start = Date.now();\r\n\r\n    if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\r\n      throw new Error('At least one of the following options must be specified: error, iterations');\r\n    } else if (typeof options.error === 'undefined') {\r\n      targetError = -1; // run until iterations\r\n    } else if (typeof options.iterations === 'undefined') {\r\n      options.iterations = 0; // run until target error\r\n    }\r\n\r\n    var fitnessFunction;\r\n    if (threads === 1) {\r\n      // Create the fitness function\r\n      fitnessFunction = function (genome) {\r\n        var score = 0;\r\n        for (var i = 0; i < amount; i++) {\r\n          score -= genome.test(set, cost).error;\r\n        }\r\n\r\n        score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;\r\n        score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection\r\n\r\n        return score / amount;\r\n      };\r\n    } else {\r\n      // Serialize the dataset\r\n      var converted = multi.serializeDataSet(set);\r\n\r\n      // Create workers, send datasets\r\n      var workers = [];\r\n      if (typeof window === 'undefined') {\r\n        for (var i = 0; i < threads; i++) {\r\n          workers.push(new multi.workers.node.TestWorker(converted, cost));\r\n        }\r\n      } else {\r\n        for (var i = 0; i < threads; i++) {\r\n          workers.push(new multi.workers.browser.TestWorker(converted, cost));\r\n        }\r\n      }\r\n\r\n      fitnessFunction = function (population) {\r\n        return new Promise((resolve, reject) => {\r\n          // Create a queue\r\n          var queue = population.slice();\r\n          var done = 0;\r\n\r\n          // Start worker function\r\n          var startWorker = function (worker) {\r\n            if (!queue.length) {\r\n              if (++done === threads) resolve();\r\n              return;\r\n            }\r\n\r\n            var genome = queue.shift();\r\n\r\n            worker.evaluate(genome).then(function (result) {\r\n              genome.score = -result;\r\n              genome.score -= (genome.nodes.length - genome.input - genome.output +\r\n                genome.connections.length + genome.gates.length) * growth;\r\n              genome.score = isNaN(parseFloat(result)) ? -Infinity : genome.score;\r\n              startWorker(worker);\r\n            });\r\n          };\r\n\r\n          for (var i = 0; i < workers.length; i++) {\r\n            startWorker(workers[i]);\r\n          }\r\n        });\r\n      };\r\n\r\n      options.fitnessPopulation = true;\r\n    }\r\n\r\n    // Intialise the NEAT instance\r\n    options.network = this;\r\n    var neat = new Neat(this.input, this.output, fitnessFunction, options);\r\n\r\n    var error = -Infinity;\r\n    var bestFitness = -Infinity;\r\n    var bestGenome;\r\n\r\n    while (error < -targetError && (options.iterations === 0 || neat.generation < options.iterations)) {\r\n      let fittest = await neat.evolve();\r\n      let fitness = fittest.score;\r\n      error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;\r\n\r\n      if (fitness > bestFitness) {\r\n        bestFitness = fitness;\r\n        bestGenome = fittest;\r\n      }\r\n\r\n      if (options.log && neat.generation % options.log === 0) {\r\n        console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);\r\n      }\r\n\r\n      if (options.schedule && neat.generation % options.schedule.iterations === 0) {\r\n        options.schedule.function({ fitness: fitness, error: -error, iteration: neat.generation });\r\n      }\r\n    }\r\n\r\n    if (threads > 1) {\r\n      for (var i = 0; i < workers.length; i++) workers[i].terminate();\r\n    }\r\n\r\n    if (typeof bestGenome !== 'undefined') {\r\n      this.nodes = bestGenome.nodes;\r\n      this.connections = bestGenome.connections;\r\n      this.selfconns = bestGenome.selfconns;\r\n      this.gates = bestGenome.gates;\r\n\r\n      if (options.clear) this.clear();\r\n    }\r\n\r\n    return {\r\n      error: -error,\r\n      iterations: neat.generation,\r\n      time: Date.now() - start\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Creates a standalone function of the network which can be run without the\r\n   * need of a library\r\n   */\r\n  standalone: function () {\r\n    var present = [];\r\n    var activations = [];\r\n    var states = [];\r\n    var lines = [];\r\n    var functions = [];\r\n\r\n    var i;\r\n    for (i = 0; i < this.input; i++) {\r\n      var node = this.nodes[i];\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n    }\r\n\r\n    lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');\r\n\r\n    // So we don't have to use expensive .indexOf()\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].index = i;\r\n    }\r\n\r\n    for (i = this.input; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n\r\n      var functionIndex = present.indexOf(node.squash.name);\r\n\r\n      if (functionIndex === -1) {\r\n        functionIndex = present.length;\r\n        present.push(node.squash.name);\r\n        functions.push(node.squash.toString());\r\n      }\r\n\r\n      var incoming = [];\r\n      for (var j = 0; j < node.connections.in.length; j++) {\r\n        var conn = node.connections.in[j];\r\n        var computation = `A[${conn.from.index}] * ${conn.weight}`;\r\n\r\n        if (conn.gater != null) {\r\n          computation += ` * A[${conn.gater.index}]`;\r\n        }\r\n\r\n        incoming.push(computation);\r\n      }\r\n\r\n      if (node.connections.self.weight) {\r\n        let conn = node.connections.self;\r\n        let computation = `S[${i}] * ${conn.weight}`;\r\n\r\n        if (conn.gater != null) {\r\n          computation += ` * A[${conn.gater.index}]`;\r\n        }\r\n\r\n        incoming.push(computation);\r\n      }\r\n\r\n      var line1 = `S[${i}] = ${incoming.join(' + ')} + ${node.bias};`;\r\n      var line2 = `A[${i}] = F[${functionIndex}](S[${i}])${!node.mask ? ' * ' + node.mask : ''};`;\r\n      lines.push(line1);\r\n      lines.push(line2);\r\n    }\r\n\r\n    var output = [];\r\n    for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {\r\n      output.push(`A[${i}]`);\r\n    }\r\n\r\n    output = `return [${output.join(',')}];`;\r\n    lines.push(output);\r\n\r\n    var total = '';\r\n    total += `var F = [${functions.toString()}];\\r\\n`;\r\n    total += `var A = [${activations.toString()}];\\r\\n`;\r\n    total += `var S = [${states.toString()}];\\r\\n`;\r\n    total += `function activate(input){\\r\\n${lines.join('\\r\\n')}\\r\\n}`;\r\n\r\n    return total;\r\n  },\r\n\r\n  /**\r\n   * Serialize to send to workers efficiently\r\n   */\r\n  serialize: function () {\r\n    var activations = [];\r\n    var states = [];\r\n    var conns = [];\r\n    var squashes = [\r\n      'LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID',\r\n      'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH',\r\n      'ABSOLUTE', 'INVERSE', 'SELU'\r\n    ];\r\n\r\n    conns.push(this.input);\r\n    conns.push(this.output);\r\n\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      node.index = i;\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n    }\r\n\r\n    for (i = this.input; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      conns.push(node.index);\r\n      conns.push(node.bias);\r\n      conns.push(squashes.indexOf(node.squash.name));\r\n\r\n      conns.push(node.connections.self.weight);\r\n      conns.push(node.connections.self.gater == null ? -1 : node.connections.self.gater.index);\r\n\r\n      for (var j = 0; j < node.connections.in.length; j++) {\r\n        let conn = node.connections.in[j];\r\n\r\n        conns.push(conn.from.index);\r\n        conns.push(conn.weight);\r\n        conns.push(conn.gater == null ? -1 : conn.gater.index);\r\n      }\r\n\r\n      conns.push(-2); // stop token -> next node\r\n    }\r\n\r\n    return [activations, states, conns];\r\n  }\r\n};\r\n\r\n/**\r\n * Convert a json object to a network\r\n */\r\nNetwork.fromJSON = function (json) {\r\n  var network = new Network(json.input, json.output);\r\n  network.dropout = json.dropout;\r\n  network.nodes = [];\r\n  network.connections = [];\r\n\r\n  var i;\r\n  for (i = 0; i < json.nodes.length; i++) {\r\n    network.nodes.push(Node.fromJSON(json.nodes[i]));\r\n  }\r\n\r\n  for (i = 0; i < json.connections.length; i++) {\r\n    var conn = json.connections[i];\r\n\r\n    var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];\r\n    connection.weight = conn.weight;\r\n\r\n    if (conn.gater != null) {\r\n      network.gate(network.nodes[conn.gater], connection);\r\n    }\r\n  }\r\n\r\n  return network;\r\n};\r\n\r\n/**\r\n * Merge two networks into one\r\n */\r\nNetwork.merge = function (network1, network2) {\r\n  // Create a copy of the networks\r\n  network1 = Network.fromJSON(network1.toJSON());\r\n  network2 = Network.fromJSON(network2.toJSON());\r\n\r\n  // Check if output and input size are the same\r\n  if (network1.output !== network2.input) {\r\n    throw new Error('Output size of network1 should be the same as the input size of network2!');\r\n  }\r\n\r\n  // Redirect all connections from network2 input from network1 output\r\n  var i;\r\n  for (i = 0; i < network2.connections.length; i++) {\r\n    let conn = network2.connections[i];\r\n    if (conn.from.type === 'input') {\r\n      let index = network2.nodes.indexOf(conn.from);\r\n\r\n      // redirect\r\n      conn.from = network1.nodes[network1.nodes.length - 1 - index];\r\n    }\r\n  }\r\n\r\n  // Delete input nodes of network2\r\n  for (i = network2.input - 1; i >= 0; i--) {\r\n    network2.nodes.splice(i, 1);\r\n  }\r\n\r\n  // Change the node type of network1's output nodes (now hidden)\r\n  for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {\r\n    network1.nodes[i].type = 'hidden';\r\n  }\r\n\r\n  // Create one network from both networks\r\n  network1.connections = network1.connections.concat(network2.connections);\r\n  network1.nodes = network1.nodes.concat(network2.nodes);\r\n\r\n  return network1;\r\n};\r\n\r\n/**\r\n * Create an offspring from two parent networks\r\n */\r\nNetwork.crossOver = function (network1, network2, equal) {\r\n  if (network1.input !== network2.input || network1.output !== network2.output) {\r\n    throw new Error(\"Networks don't have the same input/output size!\");\r\n  }\r\n\r\n  // Initialise offspring\r\n  var offspring = new Network(network1.input, network1.output);\r\n  offspring.connections = [];\r\n  offspring.nodes = [];\r\n\r\n  // Save scores and create a copy\r\n  var score1 = network1.score || 0;\r\n  var score2 = network2.score || 0;\r\n\r\n  // Determine offspring node size\r\n  var size;\r\n  if (equal || score1 === score2) {\r\n    let max = Math.max(network1.nodes.length, network2.nodes.length);\r\n    let min = Math.min(network1.nodes.length, network2.nodes.length);\r\n    size = Math.floor(Math.random() * (max - min + 1) + min);\r\n  } else if (score1 > score2) {\r\n    size = network1.nodes.length;\r\n  } else {\r\n    size = network2.nodes.length;\r\n  }\r\n\r\n  // Rename some variables for easier reading\r\n  var outputSize = network1.output;\r\n\r\n  // Set indexes so we don't need indexOf\r\n  var i;\r\n  for (i = 0; i < network1.nodes.length; i++) {\r\n    network1.nodes[i].index = i;\r\n  }\r\n\r\n  for (i = 0; i < network2.nodes.length; i++) {\r\n    network2.nodes[i].index = i;\r\n  }\r\n\r\n  // Assign nodes from parents to offspring\r\n  for (i = 0; i < size; i++) {\r\n    // Determine if an output node is needed\r\n    var node;\r\n    if (i < size - outputSize) {\r\n      let random = Math.random();\r\n      node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];\r\n      let other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];\r\n\r\n      if (typeof node === 'undefined' || node.type === 'output') {\r\n        node = other;\r\n      }\r\n    } else {\r\n      if (Math.random() >= 0.5) {\r\n        node = network1.nodes[network1.nodes.length + i - size];\r\n      } else {\r\n        node = network2.nodes[network2.nodes.length + i - size];\r\n      }\r\n    }\r\n\r\n    var newNode = new Node();\r\n    newNode.bias = node.bias;\r\n    newNode.squash = node.squash;\r\n    newNode.type = node.type;\r\n\r\n    offspring.nodes.push(newNode);\r\n  }\r\n\r\n  // Create arrays of connection genes\r\n  var n1conns = {};\r\n  var n2conns = {};\r\n\r\n  // Normal connections\r\n  for (i = 0; i < network1.connections.length; i++) {\r\n    let conn = network1.connections[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n1conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Selfconnections\r\n  for (i = 0; i < network1.selfconns.length; i++) {\r\n    let conn = network1.selfconns[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n1conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Normal connections\r\n  for (i = 0; i < network2.connections.length; i++) {\r\n    let conn = network2.connections[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n2conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Selfconnections\r\n  for (i = 0; i < network2.selfconns.length; i++) {\r\n    let conn = network2.selfconns[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n2conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Split common conn genes from disjoint or excess conn genes\r\n  var connections = [];\r\n  var keys1 = Object.keys(n1conns);\r\n  var keys2 = Object.keys(n2conns);\r\n  for (i = keys1.length - 1; i >= 0; i--) {\r\n    // Common gene\r\n    if (typeof n2conns[keys1[i]] !== 'undefined') {\r\n      let conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];\r\n      connections.push(conn);\r\n\r\n      // Because deleting is expensive, just set it to some value\r\n      n2conns[keys1[i]] = undefined;\r\n    } else if (score1 >= score2 || equal) {\r\n      connections.push(n1conns[keys1[i]]);\r\n    }\r\n  }\r\n\r\n  // Excess/disjoint gene\r\n  if (score2 >= score1 || equal) {\r\n    for (i = 0; i < keys2.length; i++) {\r\n      if (typeof n2conns[keys2[i]] !== 'undefined') {\r\n        connections.push(n2conns[keys2[i]]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add common conn genes uniformly\r\n  for (i = 0; i < connections.length; i++) {\r\n    let connData = connections[i];\r\n    if (connData.to < size && connData.from < size) {\r\n      let from = offspring.nodes[connData.from];\r\n      let to = offspring.nodes[connData.to];\r\n      let conn = offspring.connect(from, to)[0];\r\n\r\n      conn.weight = connData.weight;\r\n\r\n      if (connData.gater !== -1 && connData.gater < size) {\r\n        offspring.gate(offspring.nodes[connData.gater], conn);\r\n      }\r\n    }\r\n  }\r\n\r\n  return offspring;\r\n};\r\n", "/* Export */\r\nmodule.exports = Layer;\r\n\r\n/* Import */\r\nvar methods = require('../methods/methods');\r\nvar Group = require('./group');\r\nvar Node = require('./node');\r\n\r\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\r\n\r\nfunction Layer () {\r\n  this.output = null;\r\n\r\n  this.nodes = [];\r\n  this.connections = { in: [],\r\n    out: [],\r\n    self: []\r\n  };\r\n}\r\n\r\nLayer.prototype = {\r\n  /**\r\n   * Activates all the nodes in the group\r\n   */\r\n  activate: function (value) {\r\n    var values = [];\r\n\r\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var activation;\r\n      if (typeof value === 'undefined') {\r\n        activation = this.nodes[i].activate();\r\n      } else {\r\n        activation = this.nodes[i].activate(value[i]);\r\n      }\r\n\r\n      values.push(activation);\r\n    }\r\n\r\n    return values;\r\n  },\r\n\r\n  /**\r\n   * Propagates all the node in the group\r\n   */\r\n  propagate: function (rate, momentum, target) {\r\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (typeof target === 'undefined') {\r\n        this.nodes[i].propagate(rate, momentum, true);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\r\n  connect: function (target, method, weight) {\r\n    var connections;\r\n    if (target instanceof Group || target instanceof Node) {\r\n      connections = this.output.connect(target, method, weight);\r\n    } else if (target instanceof Layer) {\r\n      connections = target.input(this, method, weight);\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\r\n  gate: function (connections, method) {\r\n    this.output.gate(connections, method);\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var node = this.nodes[i];\r\n\r\n      if (node instanceof Node) {\r\n        if (typeof values.bias !== 'undefined') {\r\n          node.bias = values.bias;\r\n        }\r\n\r\n        node.squash = values.squash || node.squash;\r\n        node.type = values.type || node.type;\r\n      } else if (node instanceof Group) {\r\n        node.set(values);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\r\n  disconnect: function (target, twosided) {\r\n    twosided = twosided || false;\r\n\r\n    // In the future, disconnect will return a connection so indexOf can be used\r\n    var i, j, k;\r\n    if (target instanceof Group) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (twosided) {\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (twosided) {\r\n          for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.in[k];\r\n\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of this group\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  }\r\n};\r\n\r\nLayer.Dense = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  // Init required nodes (in activation order)\r\n  var block = new Group(size);\r\n\r\n  layer.nodes.push(block);\r\n  layer.output = block;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    return from.connect(block, method, weight);\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.LSTM = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  // Init required nodes (in activation order)\r\n  var inputGate = new Group(size);\r\n  var forgetGate = new Group(size);\r\n  var memoryCell = new Group(size);\r\n  var outputGate = new Group(size);\r\n  var outputBlock = new Group(size);\r\n\r\n  inputGate.set({\r\n    bias: 1\r\n  });\r\n  forgetGate.set({\r\n    bias: 1\r\n  });\r\n  outputGate.set({\r\n    bias: 1\r\n  });\r\n\r\n  // Set up internal connections\r\n  memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n  memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n  memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n  var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\r\n  var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);\r\n\r\n  // Set up gates\r\n  forgetGate.gate(forget, methods.gating.SELF);\r\n  outputGate.gate(output, methods.gating.OUTPUT);\r\n\r\n  // Add to nodes array\r\n  layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];\r\n\r\n  // Define output\r\n  layer.output = outputBlock;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    var connections = [];\r\n\r\n    var input = from.connect(memoryCell, method, weight);\r\n    connections = connections.concat(input);\r\n\r\n    connections = connections.concat(from.connect(inputGate, method, weight));\r\n    connections = connections.concat(from.connect(outputGate, method, weight));\r\n    connections = connections.concat(from.connect(forgetGate, method, weight));\r\n\r\n    inputGate.gate(input, methods.gating.INPUT);\r\n\r\n    return connections;\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.GRU = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  var updateGate = new Group(size);\r\n  var inverseUpdateGate = new Group(size);\r\n  var resetGate = new Group(size);\r\n  var memoryCell = new Group(size);\r\n  var output = new Group(size);\r\n  var previousOutput = new Group(size);\r\n\r\n  previousOutput.set({\r\n    bias: 0,\r\n    squash: methods.activation.IDENTITY,\r\n    type: 'constant'\r\n  });\r\n  memoryCell.set({\r\n    squash: methods.activation.TANH\r\n  });\r\n  inverseUpdateGate.set({\r\n    bias: 0,\r\n    squash: methods.activation.INVERSE,\r\n    type: 'constant'\r\n  });\r\n  updateGate.set({\r\n    bias: 1\r\n  });\r\n  resetGate.set({\r\n    bias: 0\r\n  });\r\n\r\n  // Update gate calculation\r\n  previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL);\r\n\r\n  // Inverse update gate calculation\r\n  updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1);\r\n\r\n  // Reset gate calculation\r\n  previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL);\r\n\r\n  // Memory calculation\r\n  var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n\r\n  resetGate.gate(reset, methods.gating.OUTPUT); // gate\r\n\r\n  // Output calculation\r\n  var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);\r\n  var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);\r\n\r\n  updateGate.gate(update1, methods.gating.OUTPUT);\r\n  inverseUpdateGate.gate(update2, methods.gating.OUTPUT);\r\n\r\n  // Previous output calculation\r\n  output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1);\r\n\r\n  // Add to nodes array\r\n  layer.nodes = [updateGate, inverseUpdateGate, resetGate, memoryCell, output, previousOutput];\r\n\r\n  layer.output = output;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    var connections = [];\r\n\r\n    connections = connections.concat(from.connect(updateGate, method, weight));\r\n    connections = connections.concat(from.connect(resetGate, method, weight));\r\n    connections = connections.concat(from.connect(memoryCell, method, weight));\r\n\r\n    return connections;\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.Memory = function (size, memory) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n  // Because the output can only be one group, we have to put the nodes all in \u00F3ne group\r\n\r\n  var previous = null;\r\n  var i;\r\n  for (i = 0; i < memory; i++) {\r\n    var block = new Group(size);\r\n\r\n    block.set({\r\n      squash: methods.activation.IDENTITY,\r\n      bias: 0,\r\n      type: 'constant'\r\n    });\r\n\r\n    if (previous != null) {\r\n      previous.connect(block, methods.connection.ONE_TO_ONE, 1);\r\n    }\r\n\r\n    layer.nodes.push(block);\r\n    previous = block;\r\n  }\r\n\r\n  layer.nodes.reverse();\r\n\r\n  for (i = 0; i < layer.nodes.length; i++) {\r\n    layer.nodes[i].nodes.reverse();\r\n  }\r\n\r\n  // Because output can only be \u00F3ne group, fit all memory nodes in \u00F3ne group\r\n  var outputGroup = new Group(0);\r\n  for (var group in layer.nodes) {\r\n    outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);\r\n  }\r\n  layer.output = outputGroup;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n\r\n    if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {\r\n      throw new Error('Previous layer size must be same as memory size');\r\n    }\r\n\r\n    return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);\r\n  };\r\n\r\n  return layer;\r\n};\r\n", "/* Export */\r\nmodule.exports = Group;\r\n\r\n/* Import */\r\nvar methods = require('../methods/methods');\r\nvar config = require('../config');\r\nvar Layer = require('./layer');\r\nvar Node = require('./node');\r\n\r\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\r\n\r\nfunction Group (size) {\r\n  this.nodes = [];\r\n  this.connections = {\r\n    in: [],\r\n    out: [],\r\n    self: []\r\n  };\r\n\r\n  for (var i = 0; i < size; i++) {\r\n    this.nodes.push(new Node());\r\n  }\r\n}\r\n\r\nGroup.prototype = {\r\n  /**\r\n   * Activates all the nodes in the group\r\n   */\r\n  activate: function (value) {\r\n    var values = [];\r\n\r\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var activation;\r\n      if (typeof value === 'undefined') {\r\n        activation = this.nodes[i].activate();\r\n      } else {\r\n        activation = this.nodes[i].activate(value[i]);\r\n      }\r\n\r\n      values.push(activation);\r\n    }\r\n\r\n    return values;\r\n  },\r\n\r\n  /**\r\n   * Propagates all the node in the group\r\n   */\r\n  propagate: function (rate, momentum, target) {\r\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (typeof target === 'undefined') {\r\n        this.nodes[i].propagate(rate, momentum, true);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\r\n  connect: function (target, method, weight) {\r\n    var connections = [];\r\n    var i, j;\r\n    if (target instanceof Group) {\r\n      if (typeof method === 'undefined') {\r\n        if (this !== target) {\r\n          if (config.warnings) console.warn('No group connection specified, using ALL_TO_ALL');\r\n          method = methods.connection.ALL_TO_ALL;\r\n        } else {\r\n          if (config.warnings) console.warn('No group connection specified, using ONE_TO_ONE');\r\n          method = methods.connection.ONE_TO_ONE;\r\n        }\r\n      }\r\n      if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          for (j = 0; j < target.nodes.length; j++) {\r\n            if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j]) continue;\r\n            let connection = this.nodes[i].connect(target.nodes[j], weight);\r\n            this.connections.out.push(connection[0]);\r\n            target.connections.in.push(connection[0]);\r\n            connections.push(connection[0]);\r\n          }\r\n        }\r\n      } else if (method === methods.connection.ONE_TO_ONE) {\r\n        if (this.nodes.length !== target.nodes.length) {\r\n          throw new Error('From and To group must be the same size!');\r\n        }\r\n\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          let connection = this.nodes[i].connect(target.nodes[i], weight);\r\n          this.connections.self.push(connection[0]);\r\n          connections.push(connection[0]);\r\n        }\r\n      }\r\n    } else if (target instanceof Layer) {\r\n      connections = target.input(this, method, weight);\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        let connection = this.nodes[i].connect(target, weight);\r\n        this.connections.out.push(connection[0]);\r\n        connections.push(connection[0]);\r\n      }\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\r\n  gate: function (connections, method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');\r\n    }\r\n\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    var nodes1 = [];\r\n    var nodes2 = [];\r\n\r\n    var i, j;\r\n    for (i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);\r\n      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);\r\n    }\r\n\r\n    switch (method) {\r\n      case methods.gating.INPUT:\r\n        for (i = 0; i < nodes2.length; i++) {\r\n          let node = nodes2[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          for (j = 0; j < node.connections.in.length; j++) {\r\n            let conn = node.connections.in[j];\r\n            if (connections.includes(conn)) {\r\n              gater.gate(conn);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case methods.gating.OUTPUT:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          for (j = 0; j < node.connections.out.length; j++) {\r\n            let conn = node.connections.out[j];\r\n            if (connections.includes(conn)) {\r\n              gater.gate(conn);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case methods.gating.SELF:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          if (connections.includes(node.connections.self)) {\r\n            gater.gate(node.connections.self);\r\n          }\r\n        }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (typeof values.bias !== 'undefined') {\r\n        this.nodes[i].bias = values.bias;\r\n      }\r\n\r\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\r\n      this.nodes[i].type = values.type || this.nodes[i].type;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\r\n  disconnect: function (target, twosided) {\r\n    twosided = twosided || false;\r\n\r\n    // In the future, disconnect will return a connection so indexOf can be used\r\n    var i, j, k;\r\n    if (target instanceof Group) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (twosided) {\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (twosided) {\r\n          for (j = this.connections.in.length - 1; j >= 0; j--) {\r\n            var conn = this.connections.in[j];\r\n\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(j, 1);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of this group\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  }\r\n};\r\n", "/* Import */\r\nvar methods = require('../methods/methods');\r\nvar Network = require('./network');\r\nvar Group = require('./group');\r\nvar Layer = require('./layer');\r\nvar Node = require('./node');\r\n\r\n/*******************************************************************************\r\n                                        architect\r\n*******************************************************************************/\r\n\r\nvar architect = {\r\n  /**\r\n   * Constructs a network from a given array of connected nodes\r\n   */\r\n  Construct: function (list) {\r\n    // Create a network\r\n    var network = new Network(0, 0);\r\n\r\n    // Transform all groups into nodes\r\n    var nodes = [];\r\n\r\n    var i;\r\n    for (i = 0; i < list.length; i++) {\r\n      let j;\r\n      if (list[i] instanceof Group) {\r\n        for (j = 0; j < list[i].nodes.length; j++) {\r\n          nodes.push(list[i].nodes[j]);\r\n        }\r\n      } else if (list[i] instanceof Layer) {\r\n        for (j = 0; j < list[i].nodes.length; j++) {\r\n          for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {\r\n            nodes.push(list[i].nodes[j].nodes[k]);\r\n          }\r\n        }\r\n      } else if (list[i] instanceof Node) {\r\n        nodes.push(list[i]);\r\n      }\r\n    }\r\n\r\n    // Determine input and output nodes\r\n    var inputs = [];\r\n    var outputs = [];\r\n    for (i = nodes.length - 1; i >= 0; i--) {\r\n      if (nodes[i].type === 'output' || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {\r\n        nodes[i].type = 'output';\r\n        network.output++;\r\n        outputs.push(nodes[i]);\r\n        nodes.splice(i, 1);\r\n      } else if (nodes[i].type === 'input' || !nodes[i].connections.in.length) {\r\n        nodes[i].type = 'input';\r\n        network.input++;\r\n        inputs.push(nodes[i]);\r\n        nodes.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    // Input nodes are always first, output nodes are always last\r\n    nodes = inputs.concat(nodes).concat(outputs);\r\n\r\n    if (network.input === 0 || network.output === 0) {\r\n      throw new Error('Given nodes have no clear input/output node!');\r\n    }\r\n\r\n    for (i = 0; i < nodes.length; i++) {\r\n      let j;\r\n      for (j = 0; j < nodes[i].connections.out.length; j++) {\r\n        network.connections.push(nodes[i].connections.out[j]);\r\n      }\r\n      for (j = 0; j < nodes[i].connections.gated.length; j++) {\r\n        network.gates.push(nodes[i].connections.gated[j]);\r\n      }\r\n      if (nodes[i].connections.self.weight !== 0) {\r\n        network.selfconns.push(nodes[i].connections.self);\r\n      }\r\n    }\r\n\r\n    network.nodes = nodes;\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a multilayer perceptron (MLP)\r\n   */\r\n  Perceptron: function () {\r\n    // Convert arguments to Array\r\n    var layers = Array.prototype.slice.call(arguments);\r\n    if (layers.length < 3) {\r\n      throw new Error('You have to specify at least 3 layers');\r\n    }\r\n\r\n    // Create a list of nodes/groups\r\n    var nodes = [];\r\n    nodes.push(new Group(layers[0]));\r\n\r\n    for (var i = 1; i < layers.length; i++) {\r\n      var layer = layers[i];\r\n      layer = new Group(layer);\r\n      nodes.push(layer);\r\n      nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);\r\n    }\r\n\r\n    // Construct the network\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a randomly connected network\r\n   */\r\n  Random: function (input, hidden, output, options) {\r\n    options = options || {};\r\n\r\n    var connections = options.connections || hidden * 2;\r\n    var backconnections = options.backconnections || 0;\r\n    var selfconnections = options.selfconnections || 0;\r\n    var gates = options.gates || 0;\r\n\r\n    var network = new Network(input, output);\r\n\r\n    var i;\r\n    for (i = 0; i < hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_NODE);\r\n    }\r\n\r\n    for (i = 0; i < connections - hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_CONN);\r\n    }\r\n\r\n    for (i = 0; i < backconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_BACK_CONN);\r\n    }\r\n\r\n    for (i = 0; i < selfconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_SELF_CONN);\r\n    }\r\n\r\n    for (i = 0; i < gates; i++) {\r\n      network.mutate(methods.mutation.ADD_GATE);\r\n    }\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a long short-term memory network\r\n   */\r\n  LSTM: function () {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    if (args.length < 3) {\r\n      throw new Error('You have to specify at least 3 layers');\r\n    }\r\n\r\n    var last = args.pop();\r\n\r\n    var outputLayer;\r\n    if (typeof last === 'number') {\r\n      outputLayer = new Group(last);\r\n      last = {};\r\n    } else {\r\n      outputLayer = new Group(args.pop()); // last argument\r\n    }\r\n\r\n    outputLayer.set({\r\n      type: 'output'\r\n    });\r\n\r\n    var options = {};\r\n    options.memoryToMemory = last.memoryToMemory || false;\r\n    options.outputToMemory = last.outputToMemory || false;\r\n    options.outputToGates = last.outputToGates || false;\r\n    options.inputToOutput = last.inputToOutput === undefined ? true : last.inputToOutput;\r\n    options.inputToDeep = last.inputToDeep === undefined ? true : last.inputToDeep;\r\n\r\n    var inputLayer = new Group(args.shift()); // first argument\r\n    inputLayer.set({\r\n      type: 'input'\r\n    });\r\n\r\n    var blocks = args; // all the arguments in the middle\r\n\r\n    var nodes = [];\r\n    nodes.push(inputLayer);\r\n\r\n    var previous = inputLayer;\r\n    for (var i = 0; i < blocks.length; i++) {\r\n      var block = blocks[i];\r\n\r\n      // Init required nodes (in activation order)\r\n      var inputGate = new Group(block);\r\n      var forgetGate = new Group(block);\r\n      var memoryCell = new Group(block);\r\n      var outputGate = new Group(block);\r\n      var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block);\r\n\r\n      inputGate.set({\r\n        bias: 1\r\n      });\r\n      forgetGate.set({\r\n        bias: 1\r\n      });\r\n      outputGate.set({\r\n        bias: 1\r\n      });\r\n\r\n      // Connect the input with all the nodes\r\n      var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n      previous.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n      previous.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      previous.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n\r\n      // Set up internal connections\r\n      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\r\n      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);\r\n\r\n      // Set up gates\r\n      inputGate.gate(input, methods.gating.INPUT);\r\n      forgetGate.gate(forget, methods.gating.SELF);\r\n      outputGate.gate(output, methods.gating.OUTPUT);\r\n\r\n      // Input to all memory cells\r\n      if (options.inputToDeep && i > 0) {\r\n        let input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      // Optional connections\r\n      if (options.memoryToMemory) {\r\n        let input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      if (options.outputToMemory) {\r\n        let input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      if (options.outputToGates) {\r\n        outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n        outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n        outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      }\r\n\r\n      // Add to array\r\n      nodes.push(inputGate);\r\n      nodes.push(forgetGate);\r\n      nodes.push(memoryCell);\r\n      nodes.push(outputGate);\r\n      if (i !== blocks.length - 1) nodes.push(outputBlock);\r\n\r\n      previous = outputBlock;\r\n    }\r\n\r\n    // input to output direct connection\r\n    if (options.inputToOutput) {\r\n      inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL);\r\n    }\r\n\r\n    nodes.push(outputLayer);\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a gated recurrent unit network\r\n   */\r\n  GRU: function () {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    if (args.length < 3) {\r\n      throw new Error('not enough layers (minimum 3) !!');\r\n    }\r\n\r\n    var inputLayer = new Group(args.shift()); // first argument\r\n    var outputLayer = new Group(args.pop()); // last argument\r\n    var blocks = args; // all the arguments in the middle\r\n\r\n    var nodes = [];\r\n    nodes.push(inputLayer);\r\n\r\n    var previous = inputLayer;\r\n    for (var i = 0; i < blocks.length; i++) {\r\n      var layer = new Layer.GRU(blocks[i]);\r\n      previous.connect(layer);\r\n      previous = layer;\r\n\r\n      nodes.push(layer);\r\n    }\r\n\r\n    previous.connect(outputLayer);\r\n    nodes.push(outputLayer);\r\n\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a hopfield network of the given size\r\n   */\r\n  Hopfield: function (size) {\r\n    var input = new Group(size);\r\n    var output = new Group(size);\r\n\r\n    input.connect(output, methods.connection.ALL_TO_ALL);\r\n\r\n    input.set({\r\n      type: 'input'\r\n    });\r\n    output.set({\r\n      squash: methods.activation.STEP,\r\n      type: 'output'\r\n    });\r\n\r\n    var network = new architect.Construct([input, output]);\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a NARX network (remember previous inputs/outputs)\r\n   */\r\n  NARX: function (inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {\r\n    if (!Array.isArray(hiddenLayers)) {\r\n      hiddenLayers = [hiddenLayers];\r\n    }\r\n\r\n    var nodes = [];\r\n\r\n    var input = new Layer.Dense(inputSize);\r\n    var inputMemory = new Layer.Memory(inputSize, previousInput);\r\n    var hidden = [];\r\n    var output = new Layer.Dense(outputSize);\r\n    var outputMemory = new Layer.Memory(outputSize, previousOutput);\r\n\r\n    nodes.push(input);\r\n    nodes.push(outputMemory);\r\n\r\n    for (var i = 0; i < hiddenLayers.length; i++) {\r\n      var hiddenLayer = new Layer.Dense(hiddenLayers[i]);\r\n      hidden.push(hiddenLayer);\r\n      nodes.push(hiddenLayer);\r\n      if (typeof hidden[i - 1] !== 'undefined') {\r\n        hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);\r\n      }\r\n    }\r\n\r\n    nodes.push(inputMemory);\r\n    nodes.push(output);\r\n\r\n    input.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n    input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);\r\n    inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n    hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);\r\n    output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);\r\n    outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n\r\n    input.set({\r\n      type: 'input'\r\n    });\r\n    output.set({\r\n      type: 'output'\r\n    });\r\n\r\n    return architect.Construct(nodes);\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = architect;\r\n", "var Neataptic = {\r\n  methods: require('./methods/methods'),\r\n  Connection: require('./architecture/connection'),\r\n  architect: require('./architecture/architect'),\r\n  Network: require('./architecture/network'),\r\n  config: require('./config'),\r\n  Group: require('./architecture/group'),\r\n  Layer: require('./architecture/layer'),\r\n  Node: require('./architecture/node'),\r\n  Neat: require('./neat'),\r\n  multi: require('./multithreading/multi')\r\n};\r\n\r\n// CommonJS & AMD\r\nif (typeof define !== 'undefined' && define.amd) {\r\n  define([], function () { return Neataptic; });\r\n}\r\n\r\n// Node.js\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = Neataptic;\r\n}\r\n\r\n// Browser\r\nif (typeof window === 'object') {\r\n  (function () {\r\n    var old = window['neataptic'];\r\n    Neataptic.ninja = function () {\r\n      window['neataptic'] = old;\r\n      return Neataptic;\r\n    };\r\n  })();\r\n\r\n  window['neataptic'] = Neataptic;\r\n}\r\n", "export default require(\"./node_modules/neataptic/src/neataptic.js\");"],
  "mappings": "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",
  "names": []
}
